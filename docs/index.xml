<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on</title><link>https://notes.ming.ac/docs/</link><description>Recent content in Docs on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:48:23 +0000</lastBuildDate><atom:link href="https://notes.ming.ac/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>02 数据结构</title><link>https://notes.ming.ac/docs/new/algorithm_02/</link><pubDate>Tue, 09 Nov 2021 12:35:01 +0800</pubDate><guid>https://notes.ming.ac/docs/new/algorithm_02/</guid><description>链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表 链表与邻接表：树与图的存储 # 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率
struct Node { int val; Node * next; }; Node * p = new Node(); 面试题较多，但是new一个节点是比较慢的，做题不需要。
用数组模拟单链表 # 最常用的邻接表，存储图和树。它们都是用邻接表存储的。
以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin &amp;gt;&amp;gt; m; init(); while ( m --) { int k, x; char op; cin &amp;gt;&amp;gt; op; if (op == 'H') { cin &amp;gt;&amp;gt; x; add_to_head(x); } else if( op == 'D') { cin &amp;gt;&amp;gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; x; add(k - 1, x); } } for (int i = head; i !</description></item></channel></rss>