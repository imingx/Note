<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>al on</title><link>https://notes.ming.ac/docs/algorithm/</link><description>Recent content in al on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:48:23 +0000</lastBuildDate><atom:link href="https://notes.ming.ac/docs/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>「Algorithm」01 基础算法</title><link>https://notes.ming.ac/docs/algorithm/algorithm_01/</link><pubDate>Tue, 09 Nov 2021 12:35:01 +0800</pubDate><guid>https://notes.ming.ac/docs/algorithm/algorithm_01/</guid><description>排序 二分 高精度 前缀和与差分 位运算 离散化 区间合并 消除同步 # ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。 scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。 可以使用freopen 还可以加上 cin.tie(0) 来解除c++运行库层面的对数据传输的绑定。
排序 # 1. 快速排序 # 基于分治。
确定一个分界点，比如（以1开始）,取q[1]，q[(1+r)/2] ,q[r]， 随机为x 调整区间，小于等于x的在左边，大于等于x的在右边。等于x的可以在左边也可以在右边，也可以在边界上，不稳定。 递归处理左右两段。 方法一:
开两个额外的数组,a[]，b[] 扫描q数组，如果q[i] ≤ x，存入a，如果q[i]&amp;gt;x，存入b。 然后将a数组的数存入q，b数组的数存入q。 方法二：
i和j指针，i指向初始，j指向末尾。然后i向右走，直到遇到一个大于x的数。j向左走，直到遇到一个小于等于x的数。然后交换，直到 j ≤ i. 模板：
#include &amp;lt;iostream&amp;gt; using namespace std; const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int q[], int l, int r) { if (l &amp;gt;= r) return; int x = q[(l+r) &amp;gt;&amp;gt; 1], i = l - 1, j = r + 1; while( i &amp;lt; j){ do i ++ ; while (q[i] &amp;lt; x); do j -- ; while (q[j] &amp;gt; x); if (i &amp;lt; j ) swap(q[i],q[j]); } //j可能比i小，也可能等于i。 quick_sort(q, l, j); //也可以换成 l, i -1 quick_sort(q, j + 1, r); //换成 i, r //后来说明不能换成i，因为也是会出现死循环问题。 //遇到这种情况，就考虑0,1。 //用j的话，x不能取右边界，（j可以取q[l]、q[(l+r)/2]） //j不能取 q[r]、q[(l+r+1)/2] //用i的话，x不能取左边界。 (i可以取q[r]、q[(l+r+1)/2]) //i不能取 q[l]、q[(l+r)/2] } //当下面换成i,r时，不能取x=q[l]，因为会出现死循环的问题。比如排序1，2 //i最终为0，j也是0，这样使用quick_sort()会死循环。 //同理，如果取j+1,r，不能取右边界。 int main(){ scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for(int i = 0; i &amp;lt; n; i ++ ) scanf(&amp;quot;%d&amp;quot;,&amp;amp;q[i]); quick_sort(q,0,n-1); for(int i = 0; i &amp;lt; n; i ++ ) printf(&amp;quot;%d &amp;quot;,q[i]); return 0; } 排序的话，可以使用 #include&amp;lt;algorithm&amp;gt; sort(q, q+n); 2.</description></item><item><title>「Algorithm」02 数据结构</title><link>https://notes.ming.ac/docs/algorithm/algorithm_02/</link><pubDate>Tue, 09 Nov 2021 12:35:01 +0800</pubDate><guid>https://notes.ming.ac/docs/algorithm/algorithm_02/</guid><description>链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表 链表与邻接表：树与图的存储 # 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率
struct Node { int val; Node * next; }; Node * p = new Node(); 面试题较多，但是new一个节点是比较慢的，做题不需要。
用数组模拟单链表 # 最常用的邻接表，存储图和树。它们都是用邻接表存储的。
以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin &amp;gt;&amp;gt; m; init(); while ( m --) { int k, x; char op; cin &amp;gt;&amp;gt; op; if (op == 'H') { cin &amp;gt;&amp;gt; x; add_to_head(x); } else if( op == 'D') { cin &amp;gt;&amp;gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; x; add(k - 1, x); } } for (int i = head; i !</description></item><item><title>「Algorithm」03 搜索与图论</title><link>https://notes.ming.ac/docs/algorithm/algorithm_03/</link><pubDate>Mon, 15 Nov 2021 12:35:01 +0800</pubDate><guid>https://notes.ming.ac/docs/algorithm/algorithm_03/</guid><description>深度优先搜索DFS 广度优先搜索BFS 树与图的存储、深搜、广搜 拓扑排序 最短路 最小生成树 二分图 DFS和BFS # BFS是queue，O（2^n）是可以找最短路
DFS是stack，O（n）不具有最短程
DFS： # 求全排列的过程。
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 10; int n; int path[N]; bool st[N]; void dfs(int u) { if(u == n) { for(int i = 0; i &amp;lt; n; ++ i) cout &amp;lt;&amp;lt; path[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;; puts(&amp;quot;&amp;quot;); return; } for(int i = 1; i &amp;lt;= n; ++i) if(!st[i]){ path[u] = i; st[i] = true; dfs(u + 1); st[i] = false; } } int main(){ cin &amp;gt;&amp;gt; n; dfs(0); return 0; } n皇后问题：</description></item></channel></rss>