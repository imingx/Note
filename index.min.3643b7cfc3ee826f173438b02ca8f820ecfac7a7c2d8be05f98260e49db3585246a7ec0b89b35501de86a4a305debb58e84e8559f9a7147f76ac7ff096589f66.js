var suggestions = document.getElementById('suggestions');
var search = document.getElementById('search');

if (search !== null) {
  document.addEventListener('keydown', inputFocus);
}

function inputFocus(e) {
  if (e.ctrlKey && e.key === '/' ) {
    e.preventDefault();
    search.focus();
  }
  if (e.key === 'Escape' ) {
    search.blur();
    suggestions.classList.add('d-none');
  }
}

document.addEventListener('click', function(event) {

  var isClickInsideElement = suggestions.contains(event.target);

  if (!isClickInsideElement) {
    suggestions.classList.add('d-none');
  }

});

/*
Source:
  - https://dev.to/shubhamprakash/trap-focus-using-javascript-6a3
*/

document.addEventListener('keydown',suggestionFocus);

function suggestionFocus(e) {
  const suggestionsHidden = suggestions.classList.contains('d-none');
  if (suggestionsHidden) return;

  const focusableSuggestions= [...suggestions.querySelectorAll('a')];
  if (focusableSuggestions.length === 0) return;

  const index = focusableSuggestions.indexOf(document.activeElement);

  if (e.key === "ArrowUp") {
    e.preventDefault();
    const nextIndex = index > 0 ? index - 1 : 0;
    focusableSuggestions[nextIndex].focus();
  }
  else if (e.key === "ArrowDown") {
    e.preventDefault();
    const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
    focusableSuggestions[nextIndex].focus();
  }

}

/*
Source:
  - https://github.com/nextapps-de/flexsearch#index-documents-field-search
  - https://raw.githack.com/nextapps-de/flexsearch/master/demo/autocomplete.html
*/

(function(){

  var index = new FlexSearch.Document({
    tokenize: "forward",
    cache: 100,
    document: {
      id: 'id',
      store: [
        "href", "title", "description"
      ],
      index: ["title", "description", "content"]
    }
  });


  // Not yet supported: https://github.com/nextapps-de/flexsearch#complex-documents

  /*
  var docs = [
    {
        id: 0,
        href: "https://notes.ming.ac/docs/prologue/introduction/",
        title: "Introduction",
        description: "Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",
        content: "\u003ch2 id=\"get-started\"\u003eGet started \u003ca href=\"#get-started\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere are two main ways to get started with Doks:\u003c/p\u003e\n\u003ch3 id=\"tutorial\"\u003eTutorial \u003ca href=\"#tutorial\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e👉 \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eThe Tutorial is intended for novice to intermediate users. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003cp\u003eStep-by-step instructions on how to start a new Doks project. \u003ca href=\"https://getdoks.org/tutorial/introduction/\"\u003eTutorial →\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"quick-start\"\u003eQuick Start \u003ca href=\"#quick-start\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e👉 \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eThe Quick Start is intended for intermediate to advanced users. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003cp\u003eOne page summary of how to start a new Doks project. \u003ca href=\"/docs/prologue/quick-start/\"\u003eQuick Start →\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"go-further\"\u003eGo further \u003ca href=\"#go-further\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eRecipes, Reference Guides, Extensions, and Showcase.\u003c/p\u003e\n\u003ch3 id=\"recipes\"\u003eRecipes \u003ca href=\"#recipes\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eGet instructions on how to accomplish common tasks with Doks. \u003ca href=\"https://getdoks.org/docs/recipes/project-configuration/\"\u003eRecipes →\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"reference-guides\"\u003eReference Guides \u003ca href=\"#reference-guides\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLearn how to customize Doks to fully make it your own. \u003ca href=\"https://getdoks.org/docs/reference-guides/security/\"\u003eReference Guides →\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"extensions\"\u003eExtensions \u003ca href=\"#extensions\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eGet instructions on how to add even more to Doks. \u003ca href=\"https://getdoks.org/docs/extensions/breadcrumb-navigation/\"\u003eExtensions →\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"showcase\"\u003eShowcase \u003ca href=\"#showcase\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSee what others have build with Doks. \u003ca href=\"https://getdoks.org/showcase/electric-blocks/\"\u003eShowcase →\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"contributing\"\u003eContributing \u003ca href=\"#contributing\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFind out how to contribute to Doks. \u003ca href=\"https://getdoks.org/docs/contributing/how-to-contribute/\"\u003eContributing →\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"help\"\u003eHelp \u003ca href=\"#help\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGet help on Doks. \u003ca href=\"/docs/help/how-to-update/\"\u003eHelp →\u003c/a\u003e\u003c/p\u003e\n"
      },
    {
        id: 1,
        href: "https://notes.ming.ac/docs/prologue/quick-start/",
        title: "Quick Start",
        description: "One page summary of how to start a new Doks project.",
        content: "\u003ch2 id=\"requirements\"\u003eRequirements \u003ca href=\"#requirements\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDoks uses npm to centralize dependency management, making it \u003ca href=\"/docs/help/how-to-update/\"\u003eeasy to update\u003c/a\u003e resources, build tooling, plugins, and build scripts:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDownload and install \u003ca href=\"https://nodejs.org/\"\u003eNode.js\u003c/a\u003e (it includes npm) for your platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"start-a-new-doks-project\"\u003eStart a new Doks project \u003ca href=\"#start-a-new-doks-project\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCreate a new site, change directories, install dependencies, and start development server.\u003c/p\u003e\n\u003ch3 id=\"create-a-new-site\"\u003eCreate a new site \u003ca href=\"#create-a-new-site\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eDoks is available as a child theme, and a starter theme:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUse the Doks child theme, if you do \u003cstrong\u003enot\u003c/strong\u003e plan to customize a lot, and/or need future Doks updates.\u003c/li\u003e\n\u003cli\u003eUse the Doks starter theme, if you plan to customize a lot, and/or do \u003cstrong\u003enot\u003c/strong\u003e need future Doks updates.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNot quite sure? Use the Doks child theme.\u003c/p\u003e\n\u003ch4 id=\"doks-child-theme\"\u003eDoks child theme \u003ca href=\"#doks-child-theme\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone https://github.com/h-enk/doks-child-theme.git my-doks-site\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"doks-starter-theme\"\u003eDoks starter theme \u003ca href=\"#doks-starter-theme\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone https://github.com/h-enk/doks.git my-doks-site\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"change-directories\"\u003eChange directories \u003ca href=\"#change-directories\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecd my-doks-site\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"install-dependencies\"\u003eInstall dependencies \u003ca href=\"#install-dependencies\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm install\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"start-development-server\"\u003eStart development server \u003ca href=\"#start-development-server\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run start\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDoks will start the Hugo development webserver accessible by default at \u003ccode\u003ehttp://localhost:1313\u003c/code\u003e. Saved changes will live reload in the browser.\u003c/p\u003e\n\u003ch2 id=\"other-commands\"\u003eOther commands \u003ca href=\"#other-commands\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDoks comes with commands for common tasks. \u003ca href=\"/docs/prologue/commands/\"\u003eCommands →\u003c/a\u003e\u003c/p\u003e\n"
      },
    {
        id: 2,
        href: "https://notes.ming.ac/docs/prologue/commands/",
        title: "Commands",
        description: "Doks comes with commands for common tasks.",
        content: "\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e💡 \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eYou can change the commands in the scripts section of `./package.json`. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003ch2 id=\"create\"\u003ecreate \u003ca href=\"#create\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCreate new content for your site:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run create [path] [flags]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSee also the Hugo docs: \u003ca href=\"https://gohugo.io/commands/hugo_new/\"\u003ehugo new\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"lint\"\u003elint \u003ca href=\"#lint\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCheck scripts, styles, and markdown for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"scripts\"\u003escripts \u003ca href=\"#scripts\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCheck scripts for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint:scripts [-- --fix]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"styles\"\u003estyles \u003ca href=\"#styles\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCheck styles for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint:styles [-- --fix]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"markdown\"\u003emarkdown \u003ca href=\"#markdown\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCheck markdown for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint:markdown [-- --fix]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"clean\"\u003eclean \u003ca href=\"#clean\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDelete temporary directories:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run clean\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"start\"\u003estart \u003ca href=\"#start\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eStart local development server:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run start\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"build\"\u003ebuild \u003ca href=\"#build\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eBuild production website:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run build\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"functions\"\u003efunctions \u003ca href=\"#functions\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBuild Lambda functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run build:functions\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"preview\"\u003epreview \u003ca href=\"#preview\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBuild production website including draft and future content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run build:preview\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 3,
        href: "https://notes.ming.ac/docs/help/how-to-update/",
        title: "How to Update",
        description: "Regularly update the installed npm packages to keep your Doks website stable, usable, and secure.",
        content: "\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e💡 \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eLearn more about \u003ca href=\"https://docs.npmjs.com/about-semantic-versioning\"\u003esemantic versioning\u003c/a\u003e and \u003ca href=\"https://docs.npmjs.com/cli/v6/using-npm/semver#advanced-range-syntax\"\u003eadvanced range syntax\u003c/a\u003e. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003ch2 id=\"check-for-outdated-packages\"\u003eCheck for outdated packages \u003ca href=\"#check-for-outdated-packages\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://docs.npmjs.com/cli/v7/commands/npm-outdated\"\u003e\u003ccode\u003enpm outdated\u003c/code\u003e\u003c/a\u003e command will check the registry to see if any (or, specific) installed packages are currently outdated:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm outdated [[\u0026lt;@scope\u0026gt;/]\u0026lt;pkg\u0026gt; ...]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"update-packages\"\u003eUpdate packages \u003ca href=\"#update-packages\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://docs.npmjs.com/cli/v7/commands/npm-update\"\u003e\u003ccode\u003enpm update\u003c/code\u003e\u003c/a\u003e command will update all the packages listed to the latest version (specified by the tag config), respecting semver:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm update [\u0026lt;pkg\u0026gt;...]\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 4,
        href: "https://notes.ming.ac/docs/help/troubleshooting/",
        title: "Troubleshooting",
        description: "Solutions to common problems.",
        content: "\u003ch2 id=\"problems-updating-npm-packages\"\u003eProblems updating npm packages \u003ca href=\"#problems-updating-npm-packages\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDelete the \u003ccode\u003e./node_modules\u003c/code\u003e folder, and run again:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm install\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"problems-with-cache\"\u003eProblems with cache \u003ca href=\"#problems-with-cache\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDelete the temporary directories:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run clean\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 5,
        href: "https://notes.ming.ac/docs/help/faq/",
        title: "FAQ",
        description: "Answers to frequently asked questions.",
        content: "\u003ch2 id=\"hyas\"\u003eHyas? \u003ca href=\"#hyas\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDoks is a \u003ca href=\"https://gethyas.com/themes/\"\u003eHyas theme\u003c/a\u003e build by the creator of Hyas.\u003c/p\u003e\n\u003ch2 id=\"footer-notice\"\u003eFooter notice? \u003ca href=\"#footer-notice\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePlease keep it in place.\u003c/p\u003e\n\u003ch2 id=\"keyboard-shortcuts-for-search\"\u003eKeyboard shortcuts for search? \u003ca href=\"#keyboard-shortcuts-for-search\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003efocus: \u003ccode\u003eCtrl + /\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eselect: \u003ccode\u003e↓\u003c/code\u003e and \u003ccode\u003e↑\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eopen: \u003ccode\u003eEnter\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eclose: \u003ccode\u003eEsc\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"other-documentation\"\u003eOther documentation? \u003ca href=\"#other-documentation\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.netlify.com/\"\u003eNetlify\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://gohugo.io/documentation/\"\u003eHugo\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"can-i-get-support\"\u003eCan I get support? \u003ca href=\"#can-i-get-support\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCreate a topic:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://community.netlify.com/\"\u003eNetlify Community\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://discourse.gohugo.io/\"\u003eHugo Forums\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/h-enk/doks/discussions\"\u003eDoks Discussions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"contact-the-creator\"\u003eContact the creator? \u003ca href=\"#contact-the-creator\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSend \u003ccode\u003eh-enk\u003c/code\u003e a message:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://community.netlify.com/\"\u003eNetlify Community\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://discourse.gohugo.io/\"\u003eHugo Forums\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/h-enk/doks/discussions\"\u003eDoks Discussions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"
      },
    {
        id: 6,
        href: "https://notes.ming.ac/docs/prologue/introduction/test/",
        title: "est",
        description: "",
        content: "\u003cp\u003easd\u003c/p\u003e\n\u003cp\u003eas\u003c/p\u003e\n\u003cp\u003eda\u003c/p\u003e\n\u003cp\u003esd\u003c/p\u003e\n\u003cp\u003eas\u003c/p\u003e\n"
      },
    {
        id: 7,
        href: "https://notes.ming.ac/docs/new/algorithm_02/",
        title: "02 数据结构",
        description: "",
        content: "\u003cul\u003e\n\u003cli\u003e链表与邻接表：树与图的存储\u003c/li\u003e\n\u003cli\u003e栈与队列：单调队列、单调栈\u003c/li\u003e\n\u003cli\u003ekmp\u003c/li\u003e\n\u003cli\u003eTrie\u003c/li\u003e\n\u003cli\u003e并查集\u003c/li\u003e\n\u003cli\u003e堆\u003c/li\u003e\n\u003cli\u003eHash表\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"链表与邻接表树与图的存储\"\u003e链表与邻接表：树与图的存储 \u003ca href=\"#%e9%93%be%e8%a1%a8%e4%b8%8e%e9%82%bb%e6%8e%a5%e8%a1%a8%e6%a0%91%e4%b8%8e%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003estruct Node\n{\n\t\tint val;\n\t\tNode * next;\n};\n\nNode * p = new Node();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e面试题较多，但是new一个节点是比较慢的，做题不需要。\u003c/p\u003e\n\u003ch2 id=\"用数组模拟单链表\"\u003e用数组模拟单链表 \u003ca href=\"#%e7%94%a8%e6%95%b0%e7%bb%84%e6%a8%a1%e6%8b%9f%e5%8d%95%e9%93%be%e8%a1%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e最常用的邻接表，存储图和树。它们都是用邻接表存储的。\u003c/p\u003e\n\u003cp\u003e以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std; \n\nconst int N = 1e5 + 10;\n\n// head 表示头结点的下标\n// e[i]是节点i的值\n// ne[i] 是节点i的next指针\n// idx是一个指针，指向当前用到的点。\nint head, e[N], ne[N], idx;\n\nvoid init()\n{\n    head = -1;\n    idx = 0;    \n}\n\n//将x插入到头结点\nvoid add_to_head(int x)\n{\n    e[idx] = x, ne[idx] = head, head = idx, idx ++;\n}\n\n//将x插入到下标是k的点的后面\nvoid add(int k, int x)\n{\n    e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++;   \n}\n\n//删除k后面的节点\nvoid remove(int k)\n{\n    ne[k] = ne[ne[k]];\n}\n\nint main()\n{\n    int m;\n    cin \u0026gt;\u0026gt; m;\n    \n    init();\n    while ( m --)\n    {\n        int k, x;\n        char op;\n        \n        cin \u0026gt;\u0026gt; op;\n        if (op == 'H')\n        {\n            cin \u0026gt;\u0026gt; x;\n            add_to_head(x);\n        }\n        else if( op ==  'D')\n        {\n            cin \u0026gt;\u0026gt; k;\n            if (k == 0) head = ne[head];\n            else remove(k - 1);\n        }else {\n            cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x;\n            add(k - 1, x);\n        }\n    }\n    \n    for (int i = head; i != -1; i = ne[i])\n        cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    \n \n    return 0;   \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"用数组模拟双链表\"\u003e用数组模拟双链表 \u003ca href=\"#%e7%94%a8%e6%95%b0%e7%bb%84%e6%a8%a1%e6%8b%9f%e5%8f%8c%e9%93%be%e8%a1%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e用来优化某些问题。\u003c/p\u003e\n\u003cp\u003eint l[N], r[N];，让0是head，1是tail\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint m;\nint e[N], l[N], r[N], idx;\n\nvoid init()\n{\n    //0表示左端点，1表示右端点\n    r[0] = 1;\n    l[1] = 0;\n    idx = 2;\n}\n\nvoid add(int k, int x)\n{\n    //在k的右边插入x\n    e[idx] = x;\n    r[idx] = r[k];\n    l[idx] = k;\n    \n    l[r[k]] = idx;\n    r[k] = idx;\n\n    idx ++;\n    //如果想插入左边，只要add(l[k], x)\n}\n\nvoid remove(int k)\n{\n    r[l[k]] = r[k];\n    l[r[k]] = l[k];\n}\n\nint main() \n{\n    cin \u0026gt;\u0026gt; m;\n    \n    \n    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e邻接表，就是n个单链表.\u003c/p\u003e\n\u003ch1 id=\"栈与队列\"\u003e栈与队列 \u003ca href=\"#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e栈就是先进后出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint stk[N], tt;\n\nint main()\n{\n    初始化\n    //tt = -1; \n    \n    入栈\n    //stk[ ++ tt] = x;\n    \n    出栈\n    // return stk[tt --];\n    \n    空\n    //if (tt \u0026gt;= 0) return true;\n    //else return false;\n    \n    栈顶\n    //stk[tt];\n}\n\n实际上，令tt = 0初始化，更简洁。\n\n判空时，只要 if (tt \u0026gt; 0) return true; // if(tt) return true;\n\t\t\t\t\telse return false;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e队列：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e\nint q[N], hh = 0, tt = -1; //hh是队头， tt是队尾。队尾插入，队头弹出\n\n//插入\nq[ ++ tt] = x;\n\n//弹出：\nreturn q[hh ++];\n\nif( hh \u0026lt;= tt) not empty;\nelse empty;\n\n取出队头队尾元素：\nreturn q[hh];\nreturn q[tt];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e考验记忆力和毅力（自制力）。\u003c/p\u003e\n\u003ch2 id=\"单调栈\"\u003e单调栈： \u003ca href=\"#%e5%8d%95%e8%b0%83%e6%a0%88\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e给定一个序列，求序列中的每一个数，离他最近的左边比他小的数。否则为-1。\u003c/p\u003e\n\u003cp\u003e我们设置一个栈，对于每个x，之前的元素，应该让stk[tt] ≥ x的都出栈。\u003c/p\u003e\n\u003cp\u003e这样x再入栈，就是一个单调递增的栈序列。而找到最小的，只要找到x入栈前的栈顶即可。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n;\nint stk[N], tt;\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n;\n    \n    for(int i = 0; i \u0026lt; n; ++ i)\n    {\n        int x;\n        cin \u0026gt;\u0026gt; x;\n        while(tt \u0026amp;\u0026amp; stk[tt] \u0026gt;= x) tt --;\n        if (tt) cout \u0026lt;\u0026lt; stk[tt] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n        else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n        \n        stk[++tt] = x;\n    }\n    \n    \n    return 0;\n}\n//这个算法，每个元素都最多入栈和出栈一次，所以复杂度是O（n）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"单调队列\"\u003e单调队列 \u003ca href=\"#%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.acwing.com/problem/content/156/\"\u003ehttps://www.acwing.com/problem/content/156/\u003c/a\u003e滑动窗口\u003c/p\u003e\n\u003cp\u003e一个序列，在一个窗口内，算出其最大值和最小值，窗口逐渐向右移动。\u003c/p\u003e\n\u003cp\u003e在一个窗口内，如果右边的元素比左边的元素小，\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先考虑暴力怎么做。\u003c/li\u003e\n\u003cli\u003e然后考虑在窗口移动的时候，怎样删除一些无用的元素。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果不开O2优化，那么数组比STL快一些。\u003c/p\u003e\n\u003cp\u003eO3优化\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#pragma GCC optimize(2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint a[N], q[N];\n//q是下标，也就是队列，a只是记录的值a[q[i]]是取下标的值。\nint n, k;\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n    for(int i = 0; i \u0026lt; n; ++ i)\n    {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n    }\n    \n    \n    int hh = 0, tt = -1;\n    for(int i = 0; i \u0026lt; n; i ++)\n    {\n        //判断队头是否已经出窗口\n        if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh])\n        {\n            ++ hh;\n        }\n        \n        //形成一个单调递增的序列。\n        while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i])\n            tt --;\n        q[++tt] = i;\n        if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]);\n    }\n    \n    puts(\u0026quot;\u0026quot;);\n    hh = 0, tt = -1;\n    for(int i = 0; i \u0026lt; n; ++ i)\n    {\n        if( hh \u0026lt;= tt \u0026amp;\u0026amp; i - q[hh] + 1 \u0026gt; k)\n            ++ hh;\n        while( hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i])\n            tt --;\n         q[++tt] = i;\n        if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]);\n       \n    }   \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"kmp\"\u003eKMP \u003ca href=\"#kmp\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e暴力算法怎么做？\u003c/li\u003e\n\u003cli\u003e如何去优化。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e朴素算法：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eS[N]→ p[M]\nfor(int  i = 1; i ≤ n; ++i)\u003c/p\u003e\n\u003cp\u003ebool flag = true;\u003c/p\u003e\n\u003cp\u003eint t = i;\u003c/p\u003e\n\u003cp\u003efor(int j = 1; j ≤ m; j++, t++)\u003c/p\u003e\n\u003cp\u003eif (s[t] ≠ p[j])\u003c/p\u003e\n\u003cp\u003e{\u003c/p\u003e\n\u003cp\u003eflag = false;\u003c/p\u003e\n\u003cp\u003ebreak;\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eKMP解释（以1开始）\u003c/p\u003e\n\u003cp\u003enext数组表示，next[i] = j，表示p[1, j] = p[ i - j  + 1, i]\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010, M = 1000010;\n\nint n, m;\nchar p[N], s[M];\nint ne[N];\n\nint main() {\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; \n    //index from 1    \n    \n    // 求Next\n    for(int i = 2, j = 0; i \u0026lt;= n; ++ i)\n    {\n//每次都比较 j+1与i，到最后之前，可以保证1-j已经是匹配的。除非j = 0\n        while(j \u0026amp;\u0026amp; p[i] != p[ j + 1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n        //前j个（1-j）的元素与[i-j +1, i]的元素匹配，所以ne[i] = j\n    }\n    \n    \n    for(int i = 1, j = 0; i \u0026lt;=m ; ++ i)\n    {\n        while(j \u0026amp;\u0026amp; s[i] != p[ j + 1]) j = ne[j];\n        \n        if( s[i] == p[j+1]) j++;\n        if(j == n)//前n个元素已经匹配\n        {\n            //匹配成功\n            printf(\u0026quot;%d \u0026quot;, i - n );\n            j = ne[j];\n        }\n    }\n    \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"trie树\"\u003eTrie树 \u003ca href=\"#trie%e6%a0%91\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e高效地存储和查找字符串，集合的数据结构\u003c/p\u003e\n\u003cp\u003e比如：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eabcdef\nabdef\naced\nbcdf\nbcff\ncdaa\ndcdc\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e当数量过大，可以使用二进制来表示。比如考虑汉字，直接找其二进制100000101010,每一步仅考虑1和0.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint son[N][26], cnt[N], idx;\n//下标是0的点，既是根节点，又是空节点\nchar str[N];\n\nvoid insert(char str[])\n{\n    int p = 0;\n    for(int i = 0; str[i]; ++i){\n        int u = str[i] - 'a';   \n        if (!son[p][u]) son[p][u] = ++ idx;\n        p = son[p][u];\n    }\n    cnt[p] ++;\n}\n\nint query(char str[])\n{\n    int p = 0;\n    for(int i = 0; str[i]; ++i)\n    {\n        int u = str[i] - 'a';\n        if(!son[p][u]) return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}\n\nint main()\n{\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    while(n--)\n    {\n        char op[2];\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; str;\n        if (op[0] == 'I') insert(str);\n        else cout \u0026lt;\u0026lt; query(str) \u0026lt;\u0026lt; endl;\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"并查集\"\u003e并查集 \u003ca href=\"#%e5%b9%b6%e6%9f%a5%e9%9b%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e面试和比赛，非常容易出的数据结构。\u003c/p\u003e\n\u003cp\u003e用来快速的处理：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将两个集合合并\u003c/li\u003e\n\u003cli\u003e询问两个元素是否在一个集合当中\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ebelong[x] = a，存储x属于集合a。\u003c/p\u003e\n\u003cp\u003e近乎O（1）的支持上面的两个操作。\u003c/p\u003e\n\u003cp\u003e基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示父节点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e问题1： 如何判断树根 p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e == x, x就是集合的编号\u003c/li\u003e\n\u003cli\u003e问题2：如何求x的集合编号，while(p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e ! = x) x = p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003c/li\u003e\n\u003cli\u003e问题3：如何合并两个集合：假设px是x的集合的编号，py是y的集合的编号，那么p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e = y;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e并查集的优化：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e（路径压缩）, 每次查询其父节点，只要直接指向其祖宗节点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e合并集合\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint p[N];\nint n, m;\n\nint find(int x) //返回x的祖宗节点，加上路径压缩\n{\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for(int i = 1; i \u0026lt;=n ; ++ i) p[i] = i;\n    \n    while(m --)\n    {\n        char op[2];\n//建议读入一个字符，也要使用字符串，自动过滤空格和回车\n        int a, b;\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n        if(op[0] == 'M') p[find(a)] = find(b);\n        else {\n            if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        }\n    }\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e连通块中点的数量\u003ca href=\"https://www.acwing.com/problem/content/839/\"\u003ehttps://www.acwing.com/problem/content/839/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\n//如何查询每个联通块的数量？维护根节点的size即可。\nint p[N], siz[N];\nint n, m;\n\nint find(int x) //返回x的祖宗节点，加上路径压缩\n{\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for(int i = 1; i \u0026lt;=n ; ++ i) {\n        p[i] = i;\n        siz[i] = 1;\n    }\n    \n    while(m --)\n    {\n        char op[5];\n//建议读入一个字符，也要使用字符串，自动过滤空格和回车\n        int a, b;\n        cin \u0026gt;\u0026gt; op;\n        if(op[0] == 'C')\n        {\n            cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n            if(find(a) != find(b))\n                siz[find(b)] += siz[find(a)];\n            p[find(a)] = find(b);\n            \n        } else if (op[1] == '1')\n        {\n            cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n            if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        } else\n        {\n            cin \u0026gt;\u0026gt; a;\n            cout \u0026lt;\u0026lt; siz[find(a)] \u0026lt;\u0026lt; endl;\n        }\n        \n    }\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"堆\"\u003e堆 \u003ca href=\"#%e5%a0%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e如何手写一个堆？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e插入一个数\u003c/li\u003e\n\u003cli\u003e求集合当中的最小值\u003c/li\u003e\n\u003cli\u003e删除最小值\u003c/li\u003e\n\u003cli\u003e删除任意一个元素\u003c/li\u003e\n\u003cli\u003e修改任意一个元素\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e堆的基本结构：\u003c/p\u003e\n\u003cp\u003e是一棵二叉树。是一棵完全二叉树。\u003c/p\u003e\n\u003cp\u003e以小顶堆为例，每个节点的左右子节点都大于该节点的值。\u003c/p\u003e\n\u003cp\u003e使用一个一维数组存放堆。\u003c/p\u003e\n\u003cp\u003e1号点是根节点，x的左儿子是2x，右子节点是2x+1。\u003c/p\u003e\n\u003cp\u003e操作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edown(x)，往下调整x。每次找这个节点和两个子节点的最小值，然后交换即可。\u003c/li\u003e\n\u003cli\u003eup(x)，往上调整x。每次往上和父节点比较，需要交换时交换即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e怎么插入x？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[ ++ idx] = x; up(x);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最小值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e删除最小值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[1] = heap[idx]; idx—; down(1);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e删除任意元素\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[k] = heap[size], size—; down(k); up(k);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e修改元素：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[k] = x; down(k); up(k);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n, m;\nint h[N], idx;\n\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2;\n    if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1;\n    \n    if(u!=t){\n        swap(h[u], h[t]);\n        down(t);\n    }\n}\n\nvoid up(int u)\n{\n    while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u])\n    {\n        swap(h[u/2], h[u]);\n        u/=2;\n    }   \n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for(int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;h[i]);\n    idx = n;\n    \n    for(int i = n/2; i ; -- i) down(i);\n    /*这是建立堆的过程\n    为什么从n/2开始down？\n    n/2的子孩子是最后一个元素，是完全二叉树的倒数第二层，所以这样一直递归\n    的做就好，而且时间复杂度是O(n);\n    */\n    \n    while(m--)\n    {\n        printf(\u0026quot;%d \u0026quot;, h[1]);\n        h[1] = h[idx];\n        idx --;\n        down(1);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e带映射版的堆操作:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.acwing.com/problem/content/841/\"\u003ehttps://www.acwing.com/problem/content/841/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n;\nint h[N], ph[N], hp[N], idx;\n//ph存放插入的第k个元素在堆的下标位置\n//hp存放的是堆中第j个元素在ph数组的位置索引。\n//ph和hp是互为反函数。\n\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]], ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2;\n    if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1;\n    \n    if(u!=t){\n        heap_swap(u, t);\n        down(t);\n    }\n}\n\nvoid up(int u)\n{\n    while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u])\n    {\n        heap_swap(u/2, u);\n        u/=2;\n    }   \n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n;\n    int m = 0;\n    //m是第m个插入的元素。\n    while(n --)\n    {\n        char op[10];\n        int k, x;\n        cin \u0026gt;\u0026gt; op;\n        if (!strcmp(op, \u0026quot;I\u0026quot;))\n        {\n            cin \u0026gt;\u0026gt; x;\n            idx ++;\n            m ++;\n            ph[m] = idx;\n            hp[idx] = m;\n            h[idx] = x;\n            up(idx);\n        }\n        else if (!strcmp(op, \u0026quot;PM\u0026quot;)) cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; endl;\n        else if (!strcmp(op, \u0026quot;DM\u0026quot;))\n        {\n            heap_swap(1, idx);\n            idx --;\n            down(1);\n        }\n        else if(!strcmp(op, \u0026quot;D\u0026quot;))\n        {\n            cin \u0026gt;\u0026gt; k;\n            k = ph[k];\n            heap_swap(k, idx);\n            idx --;\n            down(k), up(k);\n        } else \n        {\n            cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x;\n            k = ph[k];\n            h[k] = x;\n            down(k), up(k);\n        }\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efind()和cnt()可以改成，get()和cnt()保证不编译错误，compile ERROR。\u003c/p\u003e\n\u003ch1 id=\"hash表\"\u003eHash表 \u003ca href=\"#hash%e8%a1%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e哈希表的存储结构，认为是O(1). 如果要删除，只要开个数组标记一下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e开放寻址法\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e拉链法\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e常见情景： 把0-10^9的数映射到0-10^5的数组。\u003c/p\u003e\n\u003cp\u003ex mod 10 ^ 5 附近的质数。然后处理冲突。100003.\u003c/p\u003e\n\u003cp\u003e和离散化比较，离散是需要保序的。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e常用的字符串的哈希方式。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e//拉链法\n#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;//有memset\n\nusing namespace std;\n\nconst int N = 100003;\n//取大于10万的最小的质数。\n\nint h[N], e[N], ne[N], idx;\n\nvoid insert(int x)\n{\n    int k = (x % N + N) % N; //因为有的数是负数。\n    \n    e[idx] = x;\n    //e存值\n    ne[idx] = h[k];\n    //ne存指针\n    h[k] = idx;\n    idx ++;\n    //插入头部。\n}\n\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    for(int i = h[k]; i != -1; i = ne[i])\n    {\n        if(e[i] == x)\n            return true;\n    }\n    return false;\n}\n\nint main(){\n    int n;\n    \n    memset(h, -1, sizeof h);\n    \n    cin \u0026gt;\u0026gt; n;\n    while(n --)\n    {\n        char op[2];\n        int x;\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x;\n        \n        if(op[0] == 'I') insert(x);\n        else {\n            if (find(x)) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        }\n    }\n        \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e//开放寻址法\n#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\n//0xf3f3f3f3是10^9级别，很大，用来初始化数组\nconst int N = 2e5 + 3, null = 0x3f3f3f3f;\n//一般取三倍。\n//取质数。\nint h[N];\n\nint find(int x)\n{\n    int k = (x % N + N) % N;\n \n    while(h[k] != null \u0026amp;\u0026amp; h[k] != x)\n    {\n        k ++;\n        if(k == N) k = 0;\n    }\n    //这个过程一定会停止的，因为总共只有1e5个数字，而N是二倍，所以不担心满;\n    //结束条件时，h[k] == null 或 h[k] == x\n    return k;\n}\n\nint main(){\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    \n    memset(h, 0x3f, sizeof h);\n    \n    while(n --)\n    {\n        char op[2];\n        int x;\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x;\n        \n        int k = find(x);\n        if (op[0] == 'I')\n        {\n            h[k] = x;\n        } \n        else\n        {\n            if (h[k] != null) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        }\n        \n    }\n    \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e字符串前缀哈希法。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003estr = \u0026ldquo;ABCDEF\u0026rdquo;\nh[1] = \u0026ldquo;A\u0026rdquo; // 前1个\nh[2] = \u0026ldquo;AB\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e即处理前缀的hash，h[0] = 0\u003c/p\u003e\n\u003cp\u003e如果对字符串进行哈希？当成p进制数，a * p ^ 3 + b * p * 2 ……;再取模Q。\u003c/p\u003e\n\u003cp\u003e不能把字母映射成0.\u003c/p\u003e\n\u003cp\u003e那么前缀哈希值有什么用呢？因为我们已经知道 h[L]到h[R]的哈希值\u003c/p\u003e\n\u003cp\u003e所以求L - R的哈希值，只要 h[R] - h[L - 1] * p ^ {R-L+1};\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nconst int N = 100010, P = 131; \n\nint n, m;\nchar str[N];\nULL h[N], p[N];\n//p是存放P的n次方\n\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nint main(){\n    \n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; str + 1;\n    \n    p[0] = 1;\n    for(int i = 1; i \u0026lt;= n; ++ i)\n    {\n        p[i] = p[i - 1] * P;\n        h[i] = h[i - 1] * P + str[i];\n    }\n    \n    while( m --)\n    {\n        int l1, r1, l2, r2;   \n        cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2;\n        if(get(l1, r1) == get(l2, r2))\n        {\n            puts(\u0026quot;Yes\u0026quot;);   \n        } else {\n            puts(\u0026quot;No\u0026quot;);   \n        }\n        \n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehash算法求两个字符串相同比KMP更好\u003c/p\u003e\n\u003cp\u003eKMP更适合循环节。\u003c/p\u003e\n\u003ch1 id=\"cstl使用\"\u003eC++STL使用 \u003ca href=\"#cstl%e4%bd%bf%e7%94%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003evector 可变长数组，倍增的思想\nstring 处理字符串的利器，substr(), c_str()\nqueue, 队列，进行push(),front(), pop()\npriority_queue，优先队列，堆，push(), top(), pop()\nstack 栈，Push(), top(), pop()\n\ndeque 双端队列\n\nset, map, multiset, multimap 基于平衡二叉树（红黑树）动态维护有序序列\nunordered_set, unordered_map, unordered_multiset, unordered_multimap 哈希表\nbitset;压位\n\nlist用的不多。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"vector\"\u003evector: \u003ca href=\"#vector\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nint main()\n{\n    vector\u0026lt;int\u0026gt; a(10, 3);\n    vector\u0026lt;int\u0026gt; b[10]; //定义数组\n    //定义一个长度为10的，初始值为3的vector\n    //for(auto x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;\n    \n    a.size(); //O(1)\n    a.empty(); \n    \n    a.clear();//清空\n    /*系统分配空间时，所需时间与空间大小无关，与申请次数有关！！！\n    所以尽量减少申请空间的次数。\n    vector最初分配32的空间，然后如果不够，分配64，然后copy过去之前的元素。\n    申请长度为2 ^ n的数组，那么需要copy(1 + 2 + 2^n-1) = 2^n可以认为是O(1)\n    申请空间的次数是log(2^n) = n\n    */\n    \n    a.front();\n    a.back();\n    a.push_back();\n    a.pop_back();\n    begin();\n    end();\n    [];\n    \n\t\ta \u0026lt; b可以判断两个vector的大小，按字典序比。\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"下面是模板\"\u003e下面是模板 \u003ca href=\"#%e4%b8%8b%e9%9d%a2%e6%98%af%e6%a8%a1%e6%9d%bf\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eC++ STL简介\nvector, 变长数组，倍增的思想\n    size()  返回元素个数\n    empty()  返回是否为空\n    clear()  清空\n    front()/back()\n    push_back()/pop_back()\n    begin()/end()\n    []\n    支持比较运算，按字典序\n\npair\u0026lt;int, int\u0026gt;p;\n    first, 第一个元素\n    second, 第二个元素\n    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\t\tp = make_pair(10, 2);\n\t\tp = {10, 2};\n\t\tpair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;p;存三个\n\nstring，字符串\n    size()/length()  返回字符串长度\n    empty()\n    clear()\n    substr(起始下标，(子串长度))  返回子串\n    c_str()  返回字符串所在字符数组的起始地址\n\t\t\t\t用于用printf输出\n\t\t支持加运算：\n\t\t\t\tstring a = \u0026quot;1\u0026quot;;\n\t\t\t\ta += \u0026quot;bcd\u0026quot;;\n\nqueue, 队列\n    size()\n    empty()\n    push()  向队尾插入一个元素\n    front()  返回队头元素\n    back()  返回队尾元素\n    pop()  弹出队头元素\n\npriority_queue, 优先队列，默认是大顶堆\n    size()\n    empty()\n    push()  插入一个元素\n    top()  返回堆顶元素\n    pop()  弹出堆顶元素\n    定义成小顶堆的方式：\n\t\t\t\tpriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q;\n\t\t\n\t\tpriority_queue\u0026lt;int\u0026gt; heap;\n\t\t\t\t可以通过插入-x实现小顶堆。\n\nstack, 栈\n    size()\n    empty()\n    push()  向栈顶插入一个元素\n    top()  返回栈顶元素\n    pop()  弹出栈顶元素\n\ndeque, 双端队列，加强版vector，效率低，尽量不用\n    size()\n    empty()\n    clear()\n    front()/back()\n    push_back()/pop_back()\n    push_front()/pop_front()\n    begin()/end() 迭代器\n    [] 支持直接索引\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\n    size()\n    empty()\n    clear()\n    begin()/end()\n    ++, -- 返回前驱和后继，时间复杂度 O(logn)\n\n    set/multiset\n\t\t\t\tset不允许重复元素\n        insert()  插入一个数\n        find()  查找一个数，返回迭代器，找不到返回end迭代器\n        count()  返回某一个数的个数\n        erase()\n            (1) 输入是一个数x，删除所有x   O(k + logn)\n            (2) 输入一个迭代器，删除这个迭代器\n        lower_bound()/upper_bound()\n            lower_bound(x)  返回大于等于x的最小的数的迭代器\n            upper_bound(x)  返回大于x的最小的数的迭代器\n    map/multimap\n        insert()  插入的数是一个pair\n        erase()  输入的参数是pair或者迭代器\n        find()\n        []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n        lower_bound()/upper_bound()\n\t\t\t\t\n\t\t\t\tmap\u0026lt;string ,int\u0026gt; a;\n\t\t\t\ta[\u0026quot;yxc\u0026quot;] = 1;\n\t\t\t\tcout \u0026lt;\u0026lt; a[\u0026quot;yec\u0026quot;] \u0026lt;\u0026lt; endl;\n\t\t\t\t\nunordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()/upper_bound()， 迭代器的++，--.\n\nbitset, 圧位\n\t\t是bool数组的1/8。🐂\n    bitset\u0026lt;10000\u0026gt; s; \n\t\t~s;\n\n    ~, \u0026amp;, |, ^\n    \u0026gt;\u0026gt;, \u0026lt;\u0026lt;\n    ==, !=\n    []\n\n    count()  返回有多少个1\n\n    any()  判断是否至少有一个1\n    none()  判断是否全为0\n\n    set()  把所有位置成1\n    set(k, v)  将第k位变成v\n    reset()  把所有位变成0\n    flip()  等价于~\n    flip(k) 把第k位取反\n\n作者：yxc\n链接：https://www.acwing.com/blog/content/404/\n来源：AcWing\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 8,
        href: "https://notes.ming.ac/docs/help/",
        title: "Help",
        description: "Help Doks.",
        content: ""
      },
    {
        id: 9,
        href: "https://notes.ming.ac/docs/prologue/",
        title: "Prologue",
        description: "Prologue Doks.",
        content: ""
      },
    {
        id: 10,
        href: "https://notes.ming.ac/docs/",
        title: "Docs",
        description: "Docs Doks.",
        content: ""
      },
    ];
  */

  // https://discourse.gohugo.io/t/range-length-or-last-element/3803/2

  index.add(
    {
        id: 0,
        href: "/docs/prologue/introduction/",
        title: "Introduction",
        description: "Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",
        content: "Get started # There are two main ways to get started with Doks:\nTutorial # 👉  The Tutorial is intended for novice to intermediate users.   Step-by-step instructions on how to start a new Doks project. Tutorial →\nQuick Start # 👉  The Quick Start is intended for intermediate to advanced users.   One page summary of how to start a new Doks project. Quick Start →\nGo further # Recipes, Reference Guides, Extensions, and Showcase.\nRecipes # Get instructions on how to accomplish common tasks with Doks. Recipes →\nReference Guides # Learn how to customize Doks to fully make it your own. Reference Guides →\nExtensions # Get instructions on how to add even more to Doks. Extensions →\nShowcase # See what others have build with Doks. Showcase →\nContributing # Find out how to contribute to Doks. Contributing →\nHelp # Get help on Doks. Help →\n"
      })
      .add(
      {
        id: 1,
        href: "/docs/prologue/quick-start/",
        title: "Quick Start",
        description: "One page summary of how to start a new Doks project.",
        content: "Requirements # Doks uses npm to centralize dependency management, making it easy to update resources, build tooling, plugins, and build scripts:\n Download and install Node.js (it includes npm) for your platform.  Start a new Doks project # Create a new site, change directories, install dependencies, and start development server.\nCreate a new site # Doks is available as a child theme, and a starter theme:\n Use the Doks child theme, if you do not plan to customize a lot, and/or need future Doks updates. Use the Doks starter theme, if you plan to customize a lot, and/or do not need future Doks updates.  Not quite sure? Use the Doks child theme.\nDoks child theme # git clone https://github.com/h-enk/doks-child-theme.git my-doks-site  Doks starter theme # git clone https://github.com/h-enk/doks.git my-doks-site  Change directories # cd my-doks-site  Install dependencies # npm install  Start development server # npm run start  Doks will start the Hugo development webserver accessible by default at http://localhost:1313. Saved changes will live reload in the browser.\nOther commands # Doks comes with commands for common tasks. Commands →\n"
      })
      .add(
      {
        id: 2,
        href: "/docs/prologue/commands/",
        title: "Commands",
        description: "Doks comes with commands for common tasks.",
        content: "💡  You can change the commands in the scripts section of `./package.json`.   create # Create new content for your site:\nnpm run create [path] [flags]  See also the Hugo docs: hugo new.\nlint # Check scripts, styles, and markdown for errors:\nnpm run lint  scripts # Check scripts for errors:\nnpm run lint:scripts [-- --fix]  styles # Check styles for errors:\nnpm run lint:styles [-- --fix]  markdown # Check markdown for errors:\nnpm run lint:markdown [-- --fix]  clean # Delete temporary directories:\nnpm run clean  start # Start local development server:\nnpm run start  build # Build production website:\nnpm run build  functions # Build Lambda functions:\nnpm run build:functions  preview # Build production website including draft and future content:\nnpm run build:preview  "
      })
      .add(
      {
        id: 3,
        href: "/docs/help/how-to-update/",
        title: "How to Update",
        description: "Regularly update the installed npm packages to keep your Doks website stable, usable, and secure.",
        content: "💡  Learn more about semantic versioning and advanced range syntax.   Check for outdated packages # The npm outdated command will check the registry to see if any (or, specific) installed packages are currently outdated:\nnpm outdated [[\u0026lt;@scope\u0026gt;/]\u0026lt;pkg\u0026gt; ...]  Update packages # The npm update command will update all the packages listed to the latest version (specified by the tag config), respecting semver:\nnpm update [\u0026lt;pkg\u0026gt;...]  "
      })
      .add(
      {
        id: 4,
        href: "/docs/help/troubleshooting/",
        title: "Troubleshooting",
        description: "Solutions to common problems.",
        content: "Problems updating npm packages # Delete the ./node_modules folder, and run again:\nnpm install  Problems with cache # Delete the temporary directories:\nnpm run clean  "
      })
      .add(
      {
        id: 5,
        href: "/docs/help/faq/",
        title: "FAQ",
        description: "Answers to frequently asked questions.",
        content: "Hyas? # Doks is a Hyas theme build by the creator of Hyas.\nFooter notice? # Please keep it in place.\nKeyboard shortcuts for search? #  focus: Ctrl + / select: ↓ and ↑ open: Enter close: Esc  Other documentation? #  Netlify Hugo  Can I get support? # Create a topic:\n Netlify Community Hugo Forums Doks Discussions  Contact the creator? # Send h-enk a message:\n Netlify Community Hugo Forums Doks Discussions  "
      })
      .add(
      {
        id: 6,
        href: "/docs/prologue/introduction/test/",
        title: "est",
        description: "asd\nas\nda\nsd\nas",
        content: "asd\nas\nda\nsd\nas\n"
      })
      .add(
      {
        id: 7,
        href: "/docs/new/algorithm_02/",
        title: "02 数据结构",
        description: "链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 # 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\nstruct Node { int val; Node * next; }; Node * p = new Node();  面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 # 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == 'H') { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == 'D') { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i !",
        content: " 链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 # 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\nstruct Node { int val; Node * next; }; Node * p = new Node();  面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 # 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == 'H') { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == 'D') { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; return 0; }  用数组模拟双链表 # 用来优化某些问题。\nint l[N], r[N];，让0是head，1是tail\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int m; int e[N], l[N], r[N], idx; void init() { //0表示左端点，1表示右端点 r[0] = 1; l[1] = 0; idx = 2; } void add(int k, int x) { //在k的右边插入x e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++; //如果想插入左边，只要add(l[k], x) } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { cin \u0026gt;\u0026gt; m; }  邻接表，就是n个单链表.\n栈与队列 # 栈就是先进后出。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int stk[N], tt; int main() { 初始化 //tt = -1; 入栈 //stk[ ++ tt] = x; 出栈 // return stk[tt --]; 空 //if (tt \u0026gt;= 0) return true; //else return false; 栈顶 //stk[tt]; } 实际上，令tt = 0初始化，更简洁。 判空时，只要 if (tt \u0026gt; 0) return true; // if(tt) return true; else return false;  队列：\nint q[N], hh = 0, tt = -1; //hh是队头， tt是队尾。队尾插入，队头弹出 //插入 q[ ++ tt] = x; //弹出： return q[hh ++]; if( hh \u0026lt;= tt) not empty; else empty; 取出队头队尾元素： return q[hh]; return q[tt];  考验记忆力和毅力（自制力）。\n单调栈： # 给定一个序列，求序列中的每一个数，离他最近的左边比他小的数。否则为-1。\n我们设置一个栈，对于每个x，之前的元素，应该让stk[tt] ≥ x的都出栈。\n这样x再入栈，就是一个单调递增的栈序列。而找到最小的，只要找到x入栈前的栈顶即可。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n; int stk[N], tt; int main() { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++ i) { int x; cin \u0026gt;\u0026gt; x; while(tt \u0026amp;\u0026amp; stk[tt] \u0026gt;= x) tt --; if (tt) cout \u0026lt;\u0026lt; stk[tt] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; stk[++tt] = x; } return 0; } //这个算法，每个元素都最多入栈和出栈一次，所以复杂度是O（n）  单调队列 # https://www.acwing.com/problem/content/156/滑动窗口\n一个序列，在一个窗口内，算出其最大值和最小值，窗口逐渐向右移动。\n在一个窗口内，如果右边的元素比左边的元素小，\n 首先考虑暴力怎么做。 然后考虑在窗口移动的时候，怎样删除一些无用的元素。  如果不开O2优化，那么数组比STL快一些。\nO3优化\n#pragma GCC optimize(2)  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int a[N], q[N]; //q是下标，也就是队列，a只是记录的值a[q[i]]是取下标的值。 int n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; n; ++ i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); } int hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; i ++) { //判断队头是否已经出窗口 if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) { ++ hh; } //形成一个单调递增的序列。 while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]); } puts(\u0026quot;\u0026quot;); hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; ++ i) { if( hh \u0026lt;= tt \u0026amp;\u0026amp; i - q[hh] + 1 \u0026gt; k) ++ hh; while( hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]); } }  KMP #  暴力算法怎么做？ 如何去优化。  朴素算法：\n S[N]→ p[M] for(int i = 1; i ≤ n; ++i)\nbool flag = true;\nint t = i;\nfor(int j = 1; j ≤ m; j++, t++)\nif (s[t] ≠ p[j])\n{\nflag = false;\nbreak;\n}\n KMP解释（以1开始）\nnext数组表示，next[i] = j，表示p[1, j] = p[ i - j + 1, i]\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010, M = 1000010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; //index from 1 // 求Next for(int i = 2, j = 0; i \u0026lt;= n; ++ i) { //每次都比较 j+1与i，到最后之前，可以保证1-j已经是匹配的。除非j = 0 while(j \u0026amp;\u0026amp; p[i] != p[ j + 1]) j = ne[j]; if(p[i] == p[j+1]) j++; ne[i] = j; //前j个（1-j）的元素与[i-j +1, i]的元素匹配，所以ne[i] = j } for(int i = 1, j = 0; i \u0026lt;=m ; ++ i) { while(j \u0026amp;\u0026amp; s[i] != p[ j + 1]) j = ne[j]; if( s[i] == p[j+1]) j++; if(j == n)//前n个元素已经匹配 { //匹配成功 printf(\u0026quot;%d \u0026quot;, i - n ); j = ne[j]; } } return 0; }  Trie树 # 高效地存储和查找字符串，集合的数据结构\n比如：\n abcdef abdef aced bcdf bcff cdaa dcdc\n 当数量过大，可以使用二进制来表示。比如考虑汉字，直接找其二进制100000101010,每一步仅考虑1和0.\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010; int son[N][26], cnt[N], idx; //下标是0的点，既是根节点，又是空节点 char str[N]; void insert(char str[]) { int p = 0; for(int i = 0; str[i]; ++i){ int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++; } int query(char str[]) { int p = 0; for(int i = 0; str[i]; ++i) { int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; cin \u0026gt;\u0026gt; n; while(n--) { char op[2]; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; str; if (op[0] == 'I') insert(str); else cout \u0026lt;\u0026lt; query(str) \u0026lt;\u0026lt; endl; } return 0; }  并查集 # 面试和比赛，非常容易出的数据结构。\n用来快速的处理：\n 将两个集合合并 询问两个元素是否在一个集合当中  belong[x] = a，存储x属于集合a。\n近乎O（1）的支持上面的两个操作。\n基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示父节点。\n 问题1： 如何判断树根 p== x, x就是集合的编号 问题2：如何求x的集合编号，while(p! = x) x = p 问题3：如何合并两个集合：假设px是x的集合的编号，py是y的集合的编号，那么p= y;  并查集的优化：\n （路径压缩）, 每次查询其父节点，只要直接指向其祖宗节点。  合并集合\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; int p[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) p[i] = i; while(m --) { char op[2]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车 int a, b; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(op[0] == 'M') p[find(a)] = find(b); else { if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } } }  连通块中点的数量https://www.acwing.com/problem/content/839/\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; //如何查询每个联通块的数量？维护根节点的size即可。 int p[N], siz[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) { p[i] = i; siz[i] = 1; } while(m --) { char op[5]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车 int a, b; cin \u0026gt;\u0026gt; op; if(op[0] == 'C') { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) != find(b)) siz[find(b)] += siz[find(a)]; p[find(a)] = find(b); } else if (op[1] == '1') { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } else { cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; siz[find(a)] \u0026lt;\u0026lt; endl; } } }  堆 # 如何手写一个堆？\n 插入一个数 求集合当中的最小值 删除最小值 删除任意一个元素 修改任意一个元素  堆的基本结构：\n是一棵二叉树。是一棵完全二叉树。\n以小顶堆为例，每个节点的左右子节点都大于该节点的值。\n使用一个一维数组存放堆。\n1号点是根节点，x的左儿子是2x，右子节点是2x+1。\n操作：\n down(x)，往下调整x。每次找这个节点和两个子节点的最小值，然后交换即可。 up(x)，往上调整x。每次往上和父节点比较，需要交换时交换即可。  怎么插入x？\n heap[ ++ idx] = x; up(x);  最小值：\n heap[1]  删除最小值：\n heap[1] = heap[idx]; idx—; down(1);  删除任意元素\n heap[k] = heap[size], size—; down(k); up(k);  修改元素：\n heap[k] = x; down(k); up(k);  #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], idx; void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ swap(h[u], h[t]); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { swap(h[u/2], h[u]); u/=2; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;h[i]); idx = n; for(int i = n/2; i ; -- i) down(i); /*这是建立堆的过程 为什么从n/2开始down？ n/2的子孩子是最后一个元素，是完全二叉树的倒数第二层，所以这样一直递归 的做就好，而且时间复杂度是O(n); */ while(m--) { printf(\u0026quot;%d \u0026quot;, h[1]); h[1] = h[idx]; idx --; down(1); } return 0; }  带映射版的堆操作:\nhttps://www.acwing.com/problem/content/841/\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int n; int h[N], ph[N], hp[N], idx; //ph存放插入的第k个元素在堆的下标位置 //hp存放的是堆中第j个元素在ph数组的位置索引。 //ph和hp是互为反函数。 void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ heap_swap(u, t); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { heap_swap(u/2, u); u/=2; } } int main() { cin \u0026gt;\u0026gt; n; int m = 0; //m是第m个插入的元素。 while(n --) { char op[10]; int k, x; cin \u0026gt;\u0026gt; op; if (!strcmp(op, \u0026quot;I\u0026quot;)) { cin \u0026gt;\u0026gt; x; idx ++; m ++; ph[m] = idx; hp[idx] = m; h[idx] = x; up(idx); } else if (!strcmp(op, \u0026quot;PM\u0026quot;)) cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; endl; else if (!strcmp(op, \u0026quot;DM\u0026quot;)) { heap_swap(1, idx); idx --; down(1); } else if(!strcmp(op, \u0026quot;D\u0026quot;)) { cin \u0026gt;\u0026gt; k; k = ph[k]; heap_swap(k, idx); idx --; down(k), up(k); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; k = ph[k]; h[k] = x; down(k), up(k); } } return 0; }  find()和cnt()可以改成，get()和cnt()保证不编译错误，compile ERROR。\nHash表 #   哈希表的存储结构，认为是O(1). 如果要删除，只要开个数组标记一下。\n  开放寻址法\n  拉链法\n  常见情景： 把0-10^9的数映射到0-10^5的数组。\nx mod 10 ^ 5 附近的质数。然后处理冲突。100003.\n和离散化比较，离散是需要保序的。\n  常用的字符串的哈希方式。\n  //拉链法 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt;//有memset using namespace std; const int N = 100003; //取大于10万的最小的质数。 int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; //因为有的数是负数。 e[idx] = x; //e存值 ne[idx] = h[k]; //ne存指针 h[k] = idx; idx ++; //插入头部。 } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; memset(h, -1, sizeof h); cin \u0026gt;\u0026gt; n; while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; if(op[0] == 'I') insert(x); else { if (find(x)) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } } return 0; }  //开放寻址法 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; //0xf3f3f3f3是10^9级别，很大，用来初始化数组 const int N = 2e5 + 3, null = 0x3f3f3f3f; //一般取三倍。 //取质数。 int h[N]; int find(int x) { int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x) { k ++; if(k == N) k = 0; } //这个过程一定会停止的，因为总共只有1e5个数字，而N是二倍，所以不担心满; //结束条件时，h[k] == null 或 h[k] == x return k; } int main(){ int n; cin \u0026gt;\u0026gt; n; memset(h, 0x3f, sizeof h); while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; int k = find(x); if (op[0] == 'I') { h[k] = x; } else { if (h[k] != null) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } } return 0; }  字符串前缀哈希法。\n str = \u0026ldquo;ABCDEF\u0026rdquo; h[1] = \u0026ldquo;A\u0026rdquo; // 前1个 h[2] = \u0026ldquo;AB\u0026rdquo;\n 即处理前缀的hash，h[0] = 0\n如果对字符串进行哈希？当成p进制数，a * p ^ 3 + b * p * 2 ……;再取模Q。\n不能把字母映射成0.\n那么前缀哈希值有什么用呢？因为我们已经知道 h[L]到h[R]的哈希值\n所以求L - R的哈希值，只要 h[R] - h[L - 1] * p ^ {R-L+1};\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; //p是存放P的n次方 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; str + 1; p[0] = 1; for(int i = 1; i \u0026lt;= n; ++ i) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while( m --) { int l1, r1, l2, r2; cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2; if(get(l1, r1) == get(l2, r2)) { puts(\u0026quot;Yes\u0026quot;); } else { puts(\u0026quot;No\u0026quot;); } } return 0; }  hash算法求两个字符串相同比KMP更好\nKMP更适合循环节。\nC++STL使用 # vector 可变长数组，倍增的思想 string 处理字符串的利器，substr(), c_str() queue, 队列，进行push(),front(), pop() priority_queue，优先队列，堆，push(), top(), pop() stack 栈，Push(), top(), pop() deque 双端队列 set, map, multiset, multimap 基于平衡二叉树（红黑树）动态维护有序序列 unordered_set, unordered_map, unordered_multiset, unordered_multimap 哈希表 bitset;压位 list用的不多。  vector: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a(10, 3); vector\u0026lt;int\u0026gt; b[10]; //定义数组 //定义一个长度为10的，初始值为3的vector //for(auto x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; a.size(); //O(1) a.empty(); a.clear();//清空 /*系统分配空间时，所需时间与空间大小无关，与申请次数有关！！！ 所以尽量减少申请空间的次数。 vector最初分配32的空间，然后如果不够，分配64，然后copy过去之前的元素。 申请长度为2 ^ n的数组，那么需要copy(1 + 2 + 2^n-1) = 2^n可以认为是O(1) 申请空间的次数是log(2^n) = n */ a.front(); a.back(); a.push_back(); a.pop_back(); begin(); end(); []; a \u0026lt; b可以判断两个vector的大小，按字典序比。 return 0; }  下面是模板 # C++ STL简介 vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair\u0026lt;int, int\u0026gt;p; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） p = make_pair(10, 2); p = {10, 2}; pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;p;存三个 string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 用于用printf输出 支持加运算： string a = \u0026quot;1\u0026quot;; a += \u0026quot;bcd\u0026quot;; queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大顶堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小顶堆的方式： priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; priority_queue\u0026lt;int\u0026gt; heap; 可以通过插入-x实现小顶堆。 stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列，加强版vector，效率低，尽量不用 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() 迭代器 [] 支持直接索引 set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset set不允许重复元素 insert() 插入一个数 find() 查找一个数，返回迭代器，找不到返回end迭代器 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() map\u0026lt;string ,int\u0026gt; a; a[\u0026quot;yxc\u0026quot;] = 1; cout \u0026lt;\u0026lt; a[\u0026quot;yec\u0026quot;] \u0026lt;\u0026lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--. bitset, 圧位 是bool数组的1/8。🐂 bitset\u0026lt;10000\u0026gt; s; ~s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing  "
      })
      .add(
      {
        id: 8,
        href: "/docs/help/",
        title: "Help",
        description: "Help Doks.",
        content: ""
      })
      .add(
      {
        id: 9,
        href: "/docs/prologue/",
        title: "Prologue",
        description: "Prologue Doks.",
        content: ""
      })
      .add(
      {
        id: 10,
        href: "/docs/",
        title: "Docs",
        description: "Docs Doks.",
        content: ""
      })
      ;

  search.addEventListener('input', show_results, true);

  function show_results(){
    const maxResult = 5;
    var searchQuery = this.value;
    var results = index.search(searchQuery, {limit: maxResult, enrich: true});

    // flatten results since index.search() returns results for each indexed field
    const flatResults = new Map(); // keyed by href to dedupe results
    for (const result of results.flatMap(r => r.result)) {
      if (flatResults.has(result.doc.href)) continue;
      flatResults.set(result.doc.href, result.doc);
    }

    suggestions.innerHTML = "";
    suggestions.classList.remove('d-none');

    // inform user that no results were found
    if (flatResults.size === 0 && searchQuery) {
      const noResultsMessage = document.createElement('div')
      noResultsMessage.innerHTML = `No results for "<strong>${searchQuery}</strong>"`
      noResultsMessage.classList.add("suggestion__no-results");
      suggestions.appendChild(noResultsMessage);
      return;
    }

    // construct a list of suggestions
    for(const [href, doc] of flatResults) {
        const entry = document.createElement('div');
        suggestions.appendChild(entry);

        const a = document.createElement('a');
        a.href = href;
        entry.appendChild(a);

        const title = document.createElement('span');
        title.textContent = doc.title;
        title.classList.add("suggestion__title");
        a.appendChild(title);

        const description = document.createElement('span');
        description.textContent = doc.description;
        description.classList.add("suggestion__description");
        a.appendChild(description);

        suggestions.appendChild(entry);

        if(suggestions.childElementCount == maxResult) break;
    }
  }
}());
