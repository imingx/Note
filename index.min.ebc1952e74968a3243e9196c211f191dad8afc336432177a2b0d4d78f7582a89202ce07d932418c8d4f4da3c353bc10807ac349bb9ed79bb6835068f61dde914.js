var suggestions = document.getElementById('suggestions');
var search = document.getElementById('search');

if (search !== null) {
  document.addEventListener('keydown', inputFocus);
}

function inputFocus(e) {
  if (e.ctrlKey && e.key === '/' ) {
    e.preventDefault();
    search.focus();
  }
  if (e.key === 'Escape' ) {
    search.blur();
    suggestions.classList.add('d-none');
  }
}

document.addEventListener('click', function(event) {

  var isClickInsideElement = suggestions.contains(event.target);

  if (!isClickInsideElement) {
    suggestions.classList.add('d-none');
  }

});

/*
Source:
  - https://dev.to/shubhamprakash/trap-focus-using-javascript-6a3
*/

document.addEventListener('keydown',suggestionFocus);

function suggestionFocus(e) {
  const suggestionsHidden = suggestions.classList.contains('d-none');
  if (suggestionsHidden) return;

  const focusableSuggestions= [...suggestions.querySelectorAll('a')];
  if (focusableSuggestions.length === 0) return;

  const index = focusableSuggestions.indexOf(document.activeElement);

  if (e.key === "ArrowUp") {
    e.preventDefault();
    const nextIndex = index > 0 ? index - 1 : 0;
    focusableSuggestions[nextIndex].focus();
  }
  else if (e.key === "ArrowDown") {
    e.preventDefault();
    const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
    focusableSuggestions[nextIndex].focus();
  }

}

/*
Source:
  - https://github.com/nextapps-de/flexsearch#index-documents-field-search
  - https://raw.githack.com/nextapps-de/flexsearch/master/demo/autocomplete.html
*/

(function(){

  var index = new FlexSearch.Document({
    tokenize: "forward",
    cache: 100,
    document: {
      id: 'id',
      store: [
        "href", "title", "description"
      ],
      index: ["title", "description", "content"]
    }
  });


  // Not yet supported: https://github.com/nextapps-de/flexsearch#complex-documents

  /*
  var docs = [
    {
        id: 0,
        href: "https://notes.ming.ac/docs/algorithm/algorithm_01/",
        title: "「Algorithm」01 基础算法",
        description: "",
        content: "\u003cul\u003e\n\u003cli\u003e排序\u003c/li\u003e\n\u003cli\u003e二分\u003c/li\u003e\n\u003cli\u003e高精度\u003c/li\u003e\n\u003cli\u003e前缀和与差分\u003c/li\u003e\n\u003cli\u003e位运算\u003c/li\u003e\n\u003cli\u003e离散化\u003c/li\u003e\n\u003cli\u003e区间合并\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"消除同步\"\u003e消除同步 \u003ca href=\"#%e6%b6%88%e9%99%a4%e5%90%8c%e6%ad%a5\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。\u003c/li\u003e\n\u003cli\u003escanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。\u003c/li\u003e\n\u003cli\u003e可以使用freopen\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e还可以加上 cin.tie(0)   来解除c++运行库层面的对数据传输的绑定。\u003c/p\u003e\n\u003ch1 id=\"排序\"\u003e排序 \u003ca href=\"#%e6%8e%92%e5%ba%8f\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"1-快速排序\"\u003e1. 快速排序 \u003ca href=\"#1-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e基于分治。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e确定一个分界点，比如（以1开始）,取q[1]，q[(1+r)/2] ,q[r]， 随机为x\u003c/li\u003e\n\u003cli\u003e调整区间，小于等于x的在左边，大于等于x的在右边。等于x的可以在左边也可以在右边，也可以在边界上，不稳定。\u003c/li\u003e\n\u003cli\u003e递归处理左右两段。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e方法一:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e开两个额外的数组,a[]，b[]\u003c/li\u003e\n\u003cli\u003e扫描q数组，如果q[i] ≤ x，存入a，如果q[i]\u0026gt;x，存入b。\u003c/li\u003e\n\u003cli\u003e然后将a数组的数存入q，b数组的数存入q。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e方法二：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ei和j指针，i指向初始，j指向末尾。然后i向右走，直到遇到一个大于x的数。j向左走，直到遇到一个小于等于x的数。然后交换，直到 j ≤ i.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e模板：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint n;\nint q[N];\n\nvoid quick_sort(int q[], int l, int r)\n{\n        if (l \u0026gt;= r) return;\n        int x = q[(l+r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1;\n\n        while( i \u0026lt; j){\n                do i ++ ; while (q[i] \u0026lt; x);\n                do j -- ; while (q[j] \u0026gt; x);\n                if (i \u0026lt; j ) swap(q[i],q[j]);\n        }\n        //j可能比i小，也可能等于i。\n        quick_sort(q, l, j); //也可以换成 l, i -1\n        quick_sort(q, j + 1, r); //换成 i, r\n        //后来说明不能换成i，因为也是会出现死循环问题。\n        //遇到这种情况，就考虑0,1。\n\n        //用j的话，x不能取右边界，（j可以取q[l]、q[(l+r)/2]）\n                                //j不能取 q[r]、q[(l+r+1)/2]\n        //用i的话，x不能取左边界。 (i可以取q[r]、q[(l+r+1)/2])\n                                //i不能取 q[l]、q[(l+r)/2]\n}\n\n//当下面换成i,r时，不能取x=q[l]，因为会出现死循环的问题。比如排序1，2\n//i最终为0，j也是0，这样使用quick_sort()会死循环。\n//同理，如果取j+1,r，不能取右边界。\n\nint main(){\n\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\tfor(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026quot;%d\u0026quot;,\u0026amp;q[i]);\n\n\tquick_sort(q,0,n-1);\n\n\tfor(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026quot;%d \u0026quot;,q[i]);\n\treturn 0;\n}\n\n排序的话，可以使用\n#include\u0026lt;algorithm\u0026gt;\nsort(q, q+n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2归并排序\"\u003e2.归并排序 \u003ca href=\"#2%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e类似快排，也是分治。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e以中间点为分界点。\u003c/li\u003e\n\u003cli\u003e递归排序左边和右边。\u003c/li\u003e\n\u003cli\u003e归并左右两个有序的数组为1个有序的数组。\n\u003col\u003e\n\u003cli\u003e对两个数组，取两个指针指向数组的左端点。然后比较他们的值，取较小者，然后移动指针，接着继续比较，直到一个指针到头，然后将另一个数组的剩余值取走。\u003c/li\u003e\n\u003cli\u003e当指针指向的值相同时，取左边数组的值，保持稳定，这说明归并排序是稳定的。快排是不稳定的。而让快排稳定的话，可以用pair。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e为什么归并排序是O(nlogn),怎么分析？\u003c/p\u003e\n\u003cp\u003e归并排序总共有logn层，每层都是O(n)，所以是O(nlogn)\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_500x0_resize_box_3.png 500w\" width=\"1170\" height=\"216\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img1_hu71b10bf21b3f2d216d91e3acf03fb7ec_94015_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img1.png\" width=\"1170\" height=\"216\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint n;\nint q[N], tmp[N];\n\nvoid merge_sort(int q[], int l, int r)\n{\n\tif (l \u0026gt;= r) return;\n\n\tint mid = (l + r) \u0026gt;\u0026gt; 1; //+优先级比\u0026gt;\u0026gt;大，可以不加括号\n\t\n\tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r);\n\n\tint k = 0, i = l, j = mid + 1;\n\t\n\twhile (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r)\n\t\t\tif (q[i] \u0026lt;= q[j]) tmp[k++] = q[i++];\n\t\t\telse tmp[k++] = q[j++];\n\n\twhile ( i \u0026lt;= mid) tmp[k++] = q[i++];\n\twhile ( j \u0026lt;= r) tmp[k++] = q[j++];\t\n\n\tfor ( i = l, j = 0; i \u0026lt;= r; i++, j++) q[i] = tmp[j];\n}\n\nint main(){\n\tscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\n\tfor(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026quot;%d\u0026quot;,\u0026amp;q[i]);\n\t\t\n\tmerge_sort(q, 0, n-1);\n\n\tfor(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026quot;%d \u0026quot;,q[i]);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"二分\"\u003e二分 \u003ca href=\"#%e4%ba%8c%e5%88%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"1-整数二分\"\u003e1. 整数二分 \u003ca href=\"#1-%e6%95%b4%e6%95%b0%e4%ba%8c%e5%88%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e模板：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// 区间[l,r]被划分为[l,mid]与[mid + 1,r]时用\nint bsearch_1(int l, int r) {\n\t\twhile( l \u0026lt; r)\n\t\t{\n\t\t\t\tint mid = l + r \u0026gt;\u0026gt; 1;\n\t\t\t\tif (check(mid)) r= mid; //check判断mid是否满足性质\n\t\t\t\telse l = mid + 1;\n\t\t}\n\t\treturn l;\n}\n\n//区间[l,r]被划分成[l, mid - 1]和[mid, r]时使用。\nint bsearch_2(int l, int r){\n\t\twhile(l \u0026lt; r)\n\t\t{\t\n\t\t\t\tint mid = l + r + 1 \u0026gt;\u0026gt; 1;\n\t\t\t\tif(check(mid)) l = mid;\n\t\t\t\telse r = mid -1;\n\t\t}\n\t\treturn l;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e二分的本质：寻找区间的边界。边界的左边满足某种性质，边界的右边满足另一种性质。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_500x0_resize_box_3.png 500w\" width=\"953\" height=\"380\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img2_hu416412891583679fe7aab5a39afb2b54_138466_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img2.png\" width=\"953\" height=\"380\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003emid = (l+r+1)/2 找红色的边界点,检测中间值是否满足check。\n\u003col\u003e\n\u003cli\u003echeck检查是否满足红色。\u003c/li\u003e\n\u003cli\u003eif mid满足check，那么需要向右找，那么 l = mid;  [mid, r]\u003c/li\u003e\n\u003cli\u003eif mid不满足check，那么需要向左找，那么r = mid -1：[l , mid - 1]\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003emid = (l + r)/ 2寻找绿色的边界点。check检测是否满足绿色。\n\u003col\u003e\n\u003cli\u003eif mid 满足 check, 那么需要向左找，那么 r = mid;  [l , mid]\u003c/li\u003e\n\u003cli\u003eif mid 不满足 check, 那么需要向右找，那么 l = mid + 1;  [mid + 1, r]\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e为什么第一个需要mid = (l + r + 1)/2 ，因为如果r = l + 1，如果不加一，那么mid = l，区间的更新为：[l,r] 和[l,l]，陷入了死循环。\u003c/p\u003e\n\u003cp\u003e所以总的来说，我们如何使用上面两个？\u003c/p\u003e\n\u003cp\u003e1，2，2，3，3，4。\u003c/p\u003e\n\u003cp\u003e找3的起始坐标和终止坐标。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e//https://www.acwing.com/problem/content/791/\n#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n,m;\nint q[N];\n\nint main(){\n\t\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\t\tfor(int i = 0; i \u0026lt; n; i++ ) scanf(\u0026quot;%d\u0026quot;, \u0026amp;q[i]);\n\t\twhile(m--){\n\t\t\t\tint x;\n\t\t\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;x);\n\t\t\t\tint l = 0, r = n -1;\n\t\t\t\twhile ( l \u0026lt; r)\n\t\t\t\t{\n\t\t\t\t\t\tint mid = l + r \u0026gt;\u0026gt; 1;\n\t\t\t\t\t\tif (q[mid] \u0026gt;= x){ //找起始坐标\n\t\t\t\t\t\t\t\t r = mid;\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\t\t l = mid + 1;\n\t\t\t\t}\n\t\t\t\t// l == r\n\t\t\t\tif (q[l] != x) cout \u0026lt;\u0026lt; \u0026quot;-1 -1\u0026quot; \u0026lt;\u0026lt; endl;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\tcout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t\t\t\t\t\tint l = 0, r = n - 1;\n\t\t\t\t\t\twhile (l \u0026lt; r){\n\t\t\t\t\t\t\t\tint mid = (l + r + 1) \u0026gt;\u0026gt; 1;\n\t\t\t\t\t\t\t\tif (q[mid] \u0026lt;= x) l = mid; // l =mid，需要 l+r+1 \u0026gt;\u0026gt; 1\n\t\t\t\t\t\t\t\telse r = mid - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl;\n\t\t\t\t}\n\t\t\t\t\n\t\t}\n\n\t\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"2-浮点数二分\"\u003e2. 浮点数二分 \u003ca href=\"#2-%e6%b5%ae%e7%82%b9%e6%95%b0%e4%ba%8c%e5%88%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint main(){\n\t\t\n\t\tdouble x;\n\t\tcin \u0026gt;\u0026gt; x;\n\n\t\tdouble l = 0, r= x;\n\t\twhile( r - l \u0026gt; 1e-6){ //1e8\n\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\tif (mid * mid \u0026gt;= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\telse l = mid;\n\t\t}\n\n\t\t/*\n\t\t\t迭代100次;\n\t\t\tfor (int i = 0; i \u0026lt; 100; i++){\n\t\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\t\tif (mid * mid \u0026gt;= x)\tr = mid;\n\t\t\t\t\t\t\telse l = mid;\n\t\t\t}\n\t\t*/\t\n\t\tprintf(\u0026quot;%lf\\n\u0026quot;, l);\n\t\treturn 0;\n}\n\n//保留几位小数，增加2有效位。保留2位，1e-4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e三次方根：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cmath\u0026gt;\nusing namespace std;\n\nint main(){\n\t\t\n\t\tdouble x;\n\t\tcin \u0026gt;\u0026gt; x;\n\t    double l = -1000, r= 1000;\n\t\twhile( r - l \u0026gt; 1e-8){\n\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\tif (mid * mid *mid \u0026gt;= x)\n\t\t\t\t\t\tr = mid;\n\t\t\t\telse l = mid;\n\t\t}\n\n\t\tprintf(\u0026quot;%lf\\n\u0026quot;, l);\n\t\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e牛顿迭代法求平方根：a 是待求平方根的数\u003c/p\u003e\n\u003cp\u003e$$x = \\frac{x^2_0+a}{2x_0}$$\u003c/p\u003e\n\u003cp\u003e如何通俗易懂地讲解牛顿迭代法求开方？数值分析？ - 杨华的回答 - 知乎\nhttps://www.zhihu.com/question/20690553/answer/15864267\u003c/p\u003e\n\u003ch1 id=\"高精度\"\u003e高精度 \u003ca href=\"#%e9%ab%98%e7%b2%be%e5%ba%a6\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e只有C++需要关注。Python默认数是无限大，Java有大整数BigInteger和BigDecimal。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA + B\u003c/li\u003e\n\u003cli\u003eA - B\u003c/li\u003e\n\u003cli\u003eA * a      len(A) ≤ 10^6    a ≤ 10^9\u003c/li\u003e\n\u003cli\u003eA / a       求商和余数\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e存储方法：比如 123456789\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e给一个数组a[9]，那么a[0] = 9，a[1] = 8，……a[8] = 1，数组的低位存数字的低位。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"加法\"\u003e加法： \u003ca href=\"#%e5%8a%a0%e6%b3%95\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;string\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nvector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){\n    vector\u0026lt;int\u0026gt; C;\n    \n    int t = 0; //进位\n    for(int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i ++){\n        if (i \u0026lt; A.size()) t += A[i];\n        if (i \u0026lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    \n    if(t) C.push_back(t);\n    return C;\n}\n\n/*\nvector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){\n    vector\u0026lt;int\u0026gt; C;\n\t    \n\t\tif (A.size() \u0026lt; B.size()) return add(B,A); \n    int t = 0; //进位\n    for(int i = 0; i \u0026lt; A.size(); i ++){\n\t\t\t  t += A[i];\n        if (i \u0026lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    \n    if(t) C.push_back(t);\n    return C;\n}\n\n*/\n\nint main(){\n\t\tstring a,b;\n\t\tvector\u0026lt;int\u0026gt; A,B;\n\t\t\t\t\n\t\tcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\t\tfor (int i = a.size() - 1; i \u0026gt;= 0; i --) A.push_back(a[i] - '0');\n\t\tfor (int i = b.size() - 1; i \u0026gt;= 0; i --) B.push_back(b[i] - '0');\n\t\t\n\t\tauto C = add(A,B);\n\t\tfor (int i = C.size() - 1; i \u0026gt;= 0; i --) printf(\u0026quot;%d\u0026quot;,C[i]);\n\t\t\n\t\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果每一个存放不止一位数字：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nconst int base = 1000000000;\n\nvector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B)\n{\n    if (A.size() \u0026lt; B.size()) return add(B, A);\n\n    vector\u0026lt;int\u0026gt; C;\n    int t = 0;\n    for (int i = 0; i \u0026lt; A.size(); i ++ )\n    {\n        t += A[i];\n        if (i \u0026lt; B.size()) t += B[i];\n        C.push_back(t % base);\n        t /= base;\n    }\n\n    if (t) C.push_back(t);\n    return C;\n}\n\nint main()\n{\n    string a, b;\n    vector\u0026lt;int\u0026gt; A, B;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n\n    for (int i = a.size() - 1, s = 0, j = 0, t = 1; i \u0026gt;= 0; i -- )\n    {\n        s += (a[i] - '0') * t;\n        j ++, t *= 10;\n        if (j == 9 || i == 0)\n        {\n            A.push_back(s);\n            s = j = 0;\n            t = 1;\n        }\n    }\n    for (int i = b.size() - 1, s = 0, j = 0, t = 1; i \u0026gt;= 0; i -- )\n    {\n        s += (b[i] - '0') * t;\n        j ++, t *= 10;\n        if (j == 9 || i == 0)\n        {\n            B.push_back(s);\n            s = j = 0;\n            t = 1;\n        }\n    }\n\n    auto C = add(A, B);\n\n    cout \u0026lt;\u0026lt; C.back();\n    for (int i = C.size() - 2; i \u0026gt;= 0; i -- ) printf(\u0026quot;%09d\u0026quot;, C[i]);\n    cout \u0026lt;\u0026lt; endl;\n\n    return 0;\n}\n\n作者：yxc\n链接：https://www.acwing.com/activity/content/code/content/39792/\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"减法\"\u003e减法： \u003ca href=\"#%e5%87%8f%e6%b3%95\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nbool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B) {\n    if (A.size() != B.size()) return A.size() \u0026gt; B.size();\n    for(int i = A.size() - 1 ; i \u0026gt;= 0; i--) \n        if(A[i] != B[i])\n            return A[i] \u0026gt; B[i];\n    return true;\n}\n\nvector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt;\u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){\n    vector\u0026lt;int\u0026gt; C;\n    for (int i = 0, t =0; i \u0026lt; A.size(); ++ i){\n        t = A[i] - t;\n        if (i \u0026lt; B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n\t\t\t\t//数学，当t小于0，就可以+10，而如果t \u0026gt;=0， 就无影响；\n        if ( t \u0026lt; 0) t = 1; //有借位\n        else t = 0;\n    }\n    \n    while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back();\n    \n    return C;\n}\n\nint main(){\n    string a,b;\n    vector\u0026lt;int\u0026gt; A,B;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n    for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - '0');\n    for(int i = b.size() - 1; i \u0026gt;= 0; -- i) B.push_back(b[i] - '0');\n    \n    if (cmp(A,B)) {\n        auto C = sub(A,B);\n        for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]);\n    } else {\n        auto C = sub(B,A);\n        \n        printf(\u0026quot;-\u0026quot;);\n        for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"乘法\"\u003e乘法： \u003ca href=\"#%e4%b9%98%e6%b3%95\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nvector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt;\u0026amp;A, int b){\n    vector\u0026lt;int\u0026gt; C;\n    \n    int t = 0;\n    for(int i = 0; i \u0026lt; A.size() || t; ++ i) {\n        if (i \u0026lt; A.size()) t += A[i] * b;\n        C.push_back(t % 10);        \n        t /= 10;\n    }\n   \n    while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); \n    return C;\n}\n\nint main(){\n    string a;\n    int b;\n    vector\u0026lt;int\u0026gt; A;\n    \n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n    \n    for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - '0');\n\n    auto C = mul(A,b);\n    for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]);\n   \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"除法\"\u003e除法： \u003ca href=\"#%e9%99%a4%e6%b3%95\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;string\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nvector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) {\n    vector\u0026lt;int\u0026gt; C;\n    r = 0;\n    for(int i = A.size() - 1; i \u0026gt;= 0; -- i) {\n        r = r * 10 + A[i]; \n        C.push_back(r / b);\n        r %= b;\n    }\n    \n    reverse(C.begin(), C.end());\n    \n    while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\nint main(){\n    string a;\n    int b;\n    \n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n    \n    vector\u0026lt;int\u0026gt; A;\n    \n    for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - '0');\n    \n    int r = 0;\n    auto C = div(A, b, r);\n    \n    for(int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]);\n    \n    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"前缀和-与-差分\"\u003e前缀和 与 差分 \u003ca href=\"#%e5%89%8d%e7%bc%80%e5%92%8c-%e4%b8%8e-%e5%b7%ae%e5%88%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e前缀和与差分是逆运算。\u003c/p\u003e\n\u003ch3 id=\"前缀和\"\u003e\u003cstrong\u003e前缀和：\u003c/strong\u003e \u003ca href=\"#%e5%89%8d%e7%bc%80%e5%92%8c\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e一个长度为n的数组\u003c/li\u003e\n\u003cli\u003e然后前缀和数组,Si = 前i个数的和（从a1、a2到ai）。\u003c/li\u003e\n\u003cli\u003e定义$S_0 = 0$;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e问题是如何求Si，求前i个和即可。\u003c/p\u003e\n\u003cp\u003e！作用：求一段数字的和。比如求[l, r]，那么就是求\u003c/p\u003e\n\u003cp\u003e$$S_r - S_{l-1}$$\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n, m;\nint a[N], s[N];\n\nint main(){\n    //ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。\n    //可以，但是scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。\n    //可以使用freopen。\n    \n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for (int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n    \n    for (int i = 1; i \u0026lt;= n; ++ i) s[i] = s[i - 1] + a[i];\n    \n    while(m --)\n    {\n        int l,r;\n        scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r);\n        printf(\u0026quot;%d\\n\u0026quot;,s[r] - s[l - 1]);\n    }\n    \n    return 0;    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"二维前缀和\"\u003e二维前缀和 \u003ca href=\"#%e4%ba%8c%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg class=\"img-fluid lazyload blur-up\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img3_hu72fdd2feae27d3a01ec52cf2a527160f_24580_20x0_resize_box_3.png\" data-src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img3.png\" width=\"241\" height=\"281\" alt=\"Untitled\"\u003e\n\u003c/p\u003e\n\u003cp\u003e从$(x_1,y_1)\\ to  \\ (x_2,y_2)$，的区域的面积。那么就是：\u003c/p\u003e\n\u003cp\u003e$$S_{x_2y_2}-S_{x_2(y_1-1)}-S_{(x_1-1)y_2}+S_{(x_1-1)(y_1-1)}$$\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint n, m, q;\nconst int N = 1e3 + 10;\n\nint a[N][N], s[N][N];\n\nint main(){\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q;\n    for (int i = 1; i \u0026lt;= n; ++ i)\n        for (int j = 1; j \u0026lt;= m; ++ j){\n            scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]);\n            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];    \n        }\n    \n    while(q --){\n        int x1,y1,x2,y2;\n        scanf(\u0026quot;%d%d%d%d\u0026quot;, \u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2);\n        printf(\u0026quot;%d\\n\u0026quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1-1] + s[x1-1][y1-1]);\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"差分\"\u003e差分 \u003ca href=\"#%e5%b7%ae%e5%88%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ea数组是b数组的前缀和，b数组是a的差分。\u003c/p\u003e\n\u003cp\u003e对于a1, a2, a3……an\u003c/p\u003e\n\u003cp\u003e构造 b1, b2, b3,   bn\u003c/p\u003e\n\u003cp\u003e使得 aj  = b1 + b2 + …… + bj\u003c/p\u003e\n\u003cp\u003e\u003cimg class=\"img-fluid lazyload blur-up\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img4_hu8a482234da13ce0b184858fca4af1b9c_77344_20x0_resize_box_3.png\" data-src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img4.png\" width=\"299\" height=\"533\" alt=\"Untitled\"\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e用处：a和b数组在O（n）时间可以相互转化。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e让al到ar，[l, r]的数都加上c，用差分只要O(1)。只要让$b_l+c$，然后让 $b_{r+1}-c$\u003c/p\u003e\n\u003cp\u003e可以假定a数组和b数组全是零，只要看插入操作，即在[1, 1]的数都加上a1, [2,2]的数都加上a2\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n, m;\nint a[N], b[N];\n\nvoid insert(int l, int r, int c)\n{\n    b[l] += c;\n    b[r + 1] -= c;\n}\n\nint main(){\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    for (int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n    \n    for (int i = 1; i \u0026lt;= n; ++ i) insert(i, i, a[i]);\n\n    while(m --) {\n        int l, r, c;   \n        scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;l, \u0026amp;r, \u0026amp;c);\n        insert(l, r, c);\n    }\n        \n    for (int i = 1; i \u0026lt;= n; ++ i) {\n        b[i] += b[i-1]; //求前缀和\n        printf(\u0026quot;%d \u0026quot;, b[i]);\n    }   \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"差分矩阵\"\u003e差分矩阵 \u003ca href=\"#%e5%b7%ae%e5%88%86%e7%9f%a9%e9%98%b5\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_500x0_resize_box_3.png 500w\" width=\"422\" height=\"243\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img5_hu0524f26406dcd6ac77eb866ce8a719c6_39837_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img5.png\" width=\"422\" height=\"243\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e初始化时，也是可以相当于在(i, j)和(i, j)之间增加$a_{i,j}$\u003c/p\u003e\n\u003cp\u003eb数组是a数组的差分，a数组是b数组的前缀和。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e3 + 10;\n\nint n, m, q;\nint a[N][N], b[N][N];\n\nvoid insert(int x1, int y1, int x2, int y2, int c)\n{\n    b[x1][y1] += c;\n    b[x2 + 1][y1] -= c;\n    b[x1][y2+1] -=c;\n    b[x2+1][y2+1] +=c;\n}\n\nint main(){\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q;\n    for (int i = 1; i \u0026lt;= n; ++ i) \n        for (int j = 1; j \u0026lt;= m; ++ j)\n            scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i][j]);\n    \n    for (int i = 1; i \u0026lt;= n; ++ i)\n        for (int j = 1; j \u0026lt;= m; ++ j)\n            insert(i,j,i,j,a[i][j]);\n        \n\n    while(q --) {\n        int x1,y1,x2,y2,c;\n        scanf(\u0026quot;%d%d%d%d%d\u0026quot;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;c);\n        insert(x1, y1, x2, y2, c);\n    }\n    \n    for (int i = 1; i \u0026lt;= n; ++ i) {\n        for (int j = 1; j \u0026lt;= m; ++ j){\n            b[i][j] += b[i -1][j] + b[i][j -1] - b[i- 1][j-1]; \n            printf(\u0026quot;%d \u0026quot;, b[i][j]);\n        }\n        puts(\u0026quot;\u0026quot;);\n    }\n            \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"双指针算法\"\u003e双指针算法 \u003ca href=\"#%e5%8f%8c%e6%8c%87%e9%92%88%e7%ae%97%e6%b3%95\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e包括归并排序\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_500x0_resize_box_3.png 500w\" width=\"751\" height=\"386\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img6_hu682a613c06dcef7d45eb342b48dc4850_99221_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img6.png\" width=\"751\" height=\"386\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003efor(int i = 0, j = 0; i \u0026lt; n; ++ i){\n\t\twhile( j \u0026lt; i \u0026amp;\u0026amp; check(i, j)) ++ j;\n\t\t//具体逻辑\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e核心思想：把O(n^2)两重循环 变成 O(n).\u003c/p\u003e\n\u003cp\u003e举个例子，输入一个句子，输出每个单词：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\nint main() {\n    char str[1000];\n    \n    cin.getline(str, 1000);\n    \n    int n = strlen(str);\n    \n    for (int i = 0; i \u0026lt; n; ++ i)\n    {\n        int j = i;\n        while( j \u0026lt; n \u0026amp;\u0026amp; str[j] !=' ') ++ j;\n        for (int k = i; k \u0026lt; j; k ++) cout \u0026lt;\u0026lt; str[k];\n        \n        cout \u0026lt;\u0026lt; endl;\n        \n        i = j;\n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e799. 最长连续不重复子序列\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003echeck检验是否有重复元素\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_500x0_resize_box_3.png 500w\" width=\"575\" height=\"474\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img7_hu5a28877f1e9ad4ec9e3c17d320b7637f_68189_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img7.png\" width=\"575\" height=\"474\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e//数据很大时可以用hash table来做\n#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n;\nint a[N], s[N];\n\nint main() {\n    cin \u0026gt;\u0026gt; n;\n    \n    for (int i = 0; i \u0026lt; n; ++ i ) \n        scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\n    \n    int res = 0;\n    for (int i = 0, j = 0; i \u0026lt; n; ++ i )\n    {\n        ++ s[a[i]];\n        while (j \u0026lt;= i \u0026amp;\u0026amp; s[a[i]] \u0026gt; 1) {\n            -- s[a[j]];\n            ++ j;\n        }\n        \n        res = max(res, i - j + 1);\n    }\n    \n    cout \u0026lt;\u0026lt; res;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"位运算\"\u003e位运算 \u003ca href=\"#%e4%bd%8d%e8%bf%90%e7%ae%97\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"第k位的值\"\u003e第k位的值 \u003ca href=\"#%e7%ac%ack%e4%bd%8d%e7%9a%84%e5%80%bc\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003en的二进制表示中，第k位是几？个位是第零位。\n\u003col\u003e\n\u003cli\u003e先把第k位移到最后一位， n \u0026raquo; k\u003c/li\u003e\n\u003cli\u003e再看个位是几。x \u0026amp; 1.\u003c/li\u003e\n\u003cli\u003e即 (n \u0026raquo; k) \u0026amp; 1，\u0026raquo;运算符的优先级大于 \u0026amp;，可以不加括号。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"lowbit操作\"\u003elowbit操作。 \u003ca href=\"#lowbit%e6%93%8d%e4%bd%9c\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e可以用来统计x中的1的数量。\u003c/p\u003e\n\u003cp\u003elowbit(x)，返回x的最后一位的1。\u003c/p\u003e\n\u003cp\u003eLowbit( 1010)  ——\u0026gt; 得到最后一个1。\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_500x0_resize_box_3.png 500w\" width=\"624\" height=\"293\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img8_huc2b5851bf3eac00ecd696f0c7ca835d6_35979_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img8.png\" width=\"624\" height=\"293\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e-x = ~x + 1。 补码表示。\n\n那么 x \u0026amp; -x = x \u0026amp; ( ~x + 1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nint lowbit(int x)\n{\n    return x \u0026amp; -x;\n}\n\nint main (){\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    \n    while(n--){\n        int x;\n        cin \u0026gt;\u0026gt; x;\n        \n        int res = 0;\n        while(x) x -= lowbit(x),  ++ res;\n        cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一个数 -x 的：\u003c/p\u003e\n\u003cp\u003e原码：最高位取1.\u003c/p\u003e\n\u003cp\u003e反码：各位取反\u003c/p\u003e\n\u003cp\u003e补码：各位取反，加一。\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_500x0_resize_box_3.png 500w\" width=\"488\" height=\"295\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img9_hu7a3c359237035a2a708f4ef4c2518a1d_68992_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img9.png\" width=\"488\" height=\"295\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003ch1 id=\"离散化\"\u003e离散化 \u003ca href=\"#%e7%a6%bb%e6%95%a3%e5%8c%96\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e整数的离散化：\u003c/p\u003e\n\u003cp\u003e值域为$0-{10}^9$，个数有$10^5$。映射到0-n\u003c/p\u003e\n\u003cp\u003e比如a[]:  1, 3, 100, 2000, 500000. 将它们映射到0，1，2，3，4，\u003c/p\u003e\n\u003cp\u003e注意：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ea[]中可能有重复的元素，需要去重\u003c/li\u003e\n\u003cli\u003e如何算出a[i] 离散化后的值是多少？二分。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_500x0_resize_box_3.png 500w\" width=\"954\" height=\"534\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img10_hu6e12db6e42f69a5fc727c84120189411_169644_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img10.png\" width=\"954\" height=\"534\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003eunique是将alls数组进行去重，将重复元素放在末尾，返回值是一个迭代器，指向非重复元素的最后一个，然后在删除这些元素就好。\u003c/p\u003e\n\u003cp\u003e找到第一个≥ x的位置, 这个是边界问题。\u003c/p\u003e\n\u003cp\u003e返回r+1是映射到1,2,……n\u003c/p\u003e\n\u003ch2 id=\"unique\"\u003eUnique \u003ca href=\"#unique\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e如何实现Unique函数？\u003c/p\u003e\n\u003cp\u003e比如1 1 2 2 2 3 4 5 5 5 6\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003evector\u0026lt;int\u0026gt;::iterator unique(vector\u0026lt;int\u0026gt; \u0026amp;a)\n{\n\t\tint j = 0;\n\t\tfor(int i = 0; i \u0026lt; a.size(); ++ i )\n\t\t{\n\t\t\t\tif (!i || a[i] != a[i-1])\n\t\t\t\t\ta[j++] = a[i]\n\t\t} \n\n\t\treturn a.begin() + j;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"区间和\"\u003e区间和： \u003ca href=\"#%e5%8c%ba%e9%97%b4%e5%92%8c\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e如果数据比较小，就是前缀和和差分的问题。但是这个问题的数据量比较大，而且有负数。\u003c/p\u003e\n\u003cp\u003e这个问题，是插入的数量比较小。虽然跨度有10亿个，但是查询和插入的数量都是十万不到。所以需要离散化。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;vector\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\ntypedef pair\u0026lt;int, int\u0026gt; PII;\n\nconst int N = 300010;\n\nint n,m;\nint a[N], s[N];\n\nvector\u0026lt;int\u0026gt; alls;\nvector\u0026lt;PII\u0026gt; add, query;\n\nint find(int x)\n{\n    int l = 0, r = alls.size() - 1;\n    while (l \u0026lt; r)\n    {\n        int mid = l + r \u0026gt;\u0026gt; 1;\n        if (alls[mid] \u0026gt;= x) r = mid;\n        else l = mid + 1;\n    }\n    \n    return r + 1; \n}\n\nint main() {\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for(int i = 0; i \u0026lt; n; ++ i )\n    {\n        int x, c;\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c;\n        add.push_back({x,c});\n        \n        alls.push_back(x);\n    }\n    \n    for(int i = 0; i \u0026lt; m; ++ i)\n    {\n        int l, r;\n        cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n        query.push_back(make_pair(l,r));\n        \n        alls.push_back(l);\n        alls.push_back(r);\n    }\n    \n    sort(alls.begin(), alls.end());\n    alls.erase(unique(alls.begin(), alls.end()), alls.end());\n    \n    for(auto item : add) \n    {\n        int x = find(item.first);\n        a[x] += item.second;\n    }\n        \n    for (int i = 1; i \u0026lt;= alls.size(); ++ i) s[i] = s[i - 1] + a[i];\n    \n    for (auto item: query)\n    {\n        int l = find(item.first), r = find(item.second);\n        cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl;\n        \n    }\n    return 0;\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"区间合并\"\u003e区间合并 \u003ca href=\"#%e5%8c%ba%e9%97%b4%e5%90%88%e5%b9%b6\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e把有重叠点的区间合并\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_500x0_resize_box_3.png 500w\" width=\"918\" height=\"452\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_01/img11_huf6171abd2fc902ce23ae737aaf28d2d8_80221_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_01/img11.png\" width=\"918\" height=\"452\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nconst int N = 200010; \n\ntypedef pair\u0026lt;int, int\u0026gt; PII;\n\nvector\u0026lt;PII\u0026gt; segs;\nint n;\n\nvoid merge(vector\u0026lt;PII\u0026gt; \u0026amp; segs)\n{\n    vector\u0026lt;PII\u0026gt; res;\n    \n    sort(segs.begin(), segs.end()); //先排first，再排second\n    \n    int st = -2e9, ed = -2e9; //st = start, ed = end\n    \n    for(auto seg : segs)\n    {\n        if (ed \u0026lt; seg.first)  \n        {\n            if (st != -2e9) res.push_back({st, ed});\n            st = seg.first, ed = seg.second;\n        }\n        else \n        {\n            ed = max(ed, seg.second);\n        }\n    }\n    if (st != -2e9) res.push_back({st, ed});\n    \n    segs = res;\n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n;    \n    \n    for (int i = 0; i \u0026lt; n; ++ i)\n    {\n        int l, r;\n        cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r;\n        segs.push_back({l, r});\n    }\n    \n    merge(segs);\n    \n    cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl;\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 1,
        href: "https://notes.ming.ac/docs/algorithm/algorithm_02/",
        title: "「Algorithm」02 Data Structure",
        description: "",
        content: "\u003cul\u003e\n\u003cli\u003e链表与邻接表：树与图的存储\u003c/li\u003e\n\u003cli\u003e栈与队列：单调队列、单调栈\u003c/li\u003e\n\u003cli\u003ekmp\u003c/li\u003e\n\u003cli\u003eTrie\u003c/li\u003e\n\u003cli\u003e并查集\u003c/li\u003e\n\u003cli\u003e堆\u003c/li\u003e\n\u003cli\u003eHash表\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"链表与邻接表树与图的存储\"\u003e链表与邻接表：树与图的存储 \u003ca href=\"#%e9%93%be%e8%a1%a8%e4%b8%8e%e9%82%bb%e6%8e%a5%e8%a1%a8%e6%a0%91%e4%b8%8e%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003estruct Node\n{\n\t\tint val;\n\t\tNode * next;\n};\n\nNode * p = new Node();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e面试题较多，但是new一个节点是比较慢的，做题不需要。\u003c/p\u003e\n\u003ch2 id=\"用数组模拟单链表\"\u003e用数组模拟单链表 \u003ca href=\"#%e7%94%a8%e6%95%b0%e7%bb%84%e6%a8%a1%e6%8b%9f%e5%8d%95%e9%93%be%e8%a1%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e最常用的邻接表，存储图和树。它们都是用邻接表存储的。\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_500x0_resize_box_3.png 500w\" width=\"571\" height=\"189\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img1_hud0b792d155512f548831497d8c3ef732_29861_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img1.png\" width=\"571\" height=\"189\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std; \n\nconst int N = 1e5 + 10;\n\n// head 表示头结点的下标\n// e[i]是节点i的值\n// ne[i] 是节点i的next指针\n// idx是一个指针，指向当前用到的点。\nint head, e[N], ne[N], idx;\n\nvoid init()\n{\n    head = -1;\n    idx = 0;    \n}\n\n//将x插入到头结点\nvoid add_to_head(int x)\n{\n    e[idx] = x, ne[idx] = head, head = idx, idx ++;\n}\n\n//将x插入到下标是k的点的后面\nvoid add(int k, int x)\n{\n    e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++;   \n}\n\n//删除k后面的节点\nvoid remove(int k)\n{\n    ne[k] = ne[ne[k]];\n}\n\nint main()\n{\n    int m;\n    cin \u0026gt;\u0026gt; m;\n    \n    init();\n    while ( m --)\n    {\n        int k, x;\n        char op;\n        \n        cin \u0026gt;\u0026gt; op;\n        if (op == 'H')\n        {\n            cin \u0026gt;\u0026gt; x;\n            add_to_head(x);\n        }\n        else if( op ==  'D')\n        {\n            cin \u0026gt;\u0026gt; k;\n            if (k == 0) head = ne[head];\n            else remove(k - 1);\n        }else {\n            cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x;\n            add(k - 1, x);\n        }\n    }\n    \n    for (int i = head; i != -1; i = ne[i])\n        cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    \n \n    return 0;   \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"用数组模拟双链表\"\u003e用数组模拟双链表 \u003ca href=\"#%e7%94%a8%e6%95%b0%e7%bb%84%e6%a8%a1%e6%8b%9f%e5%8f%8c%e9%93%be%e8%a1%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e用来优化某些问题。\u003c/p\u003e\n\u003cp\u003eint l[N], r[N];，让0是head，1是tail\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_500x0_resize_box_3.png 500w\" width=\"948\" height=\"536\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img2_hu5a73a0b470a51d9cc8be9f44781aab9a_103255_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img2.png\" width=\"948\" height=\"536\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint m;\nint e[N], l[N], r[N], idx;\n\nvoid init()\n{\n    //0表示左端点，1表示右端点\n    r[0] = 1;\n    l[1] = 0;\n    idx = 2;\n}\n\nvoid add(int k, int x)\n{\n    //在k的右边插入x\n    e[idx] = x;\n    r[idx] = r[k];\n    l[idx] = k;\n    \n    l[r[k]] = idx;\n    r[k] = idx;\n\n    idx ++;\n    //如果想插入左边，只要add(l[k], x)\n}\n\nvoid remove(int k)\n{\n    r[l[k]] = r[k];\n    l[r[k]] = l[k];\n}\n\nint main() \n{\n    cin \u0026gt;\u0026gt; m;\n    \n    \n    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e邻接表，就是n个单链表.\u003c/p\u003e\n\u003ch1 id=\"栈与队列\"\u003e栈与队列 \u003ca href=\"#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e栈就是先进后出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint stk[N], tt;\n\nint main()\n{\n    初始化\n    //tt = -1; \n    \n    入栈\n    //stk[ ++ tt] = x;\n    \n    出栈\n    // return stk[tt --];\n    \n    空\n    //if (tt \u0026gt;= 0) return true;\n    //else return false;\n    \n    栈顶\n    //stk[tt];\n}\n\n实际上，令tt = 0初始化，更简洁。\n\n判空时，只要 if (tt \u0026gt; 0) return true; // if(tt) return true;\n\t\t\t\t\telse return false;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e队列：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e\nint q[N], hh = 0, tt = -1; //hh是队头， tt是队尾。队尾插入，队头弹出\n\n//插入\nq[ ++ tt] = x;\n\n//弹出：\nreturn q[hh ++];\n\nif( hh \u0026lt;= tt) not empty;\nelse empty;\n\n取出队头队尾元素：\nreturn q[hh];\nreturn q[tt];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e考验记忆力和毅力（自制力）。\u003c/p\u003e\n\u003ch2 id=\"单调栈\"\u003e单调栈： \u003ca href=\"#%e5%8d%95%e8%b0%83%e6%a0%88\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e给定一个序列，求序列中的每一个数，离他最近的左边比他小的数。否则为-1。\u003c/p\u003e\n\u003cp\u003e我们设置一个栈，对于每个x，之前的元素，应该让stk[tt] ≥ x的都出栈。\u003c/p\u003e\n\u003cp\u003e这样x再入栈，就是一个单调递增的栈序列。而找到最小的，只要找到x入栈前的栈顶即可。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n;\nint stk[N], tt;\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n;\n    \n    for(int i = 0; i \u0026lt; n; ++ i)\n    {\n        int x;\n        cin \u0026gt;\u0026gt; x;\n        while(tt \u0026amp;\u0026amp; stk[tt] \u0026gt;= x) tt --;\n        if (tt) cout \u0026lt;\u0026lt; stk[tt] \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n        else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n        \n        stk[++tt] = x;\n    }\n    \n    \n    return 0;\n}\n//这个算法，每个元素都最多入栈和出栈一次，所以复杂度是O（n）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"单调队列\"\u003e单调队列 \u003ca href=\"#%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.acwing.com/problem/content/156/\"\u003ehttps://www.acwing.com/problem/content/156/\u003c/a\u003e滑动窗口\u003c/p\u003e\n\u003cp\u003e一个序列，在一个窗口内，算出其最大值和最小值，窗口逐渐向右移动。\u003c/p\u003e\n\u003cp\u003e在一个窗口内，如果右边的元素比左边的元素小，\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先考虑暴力怎么做。\u003c/li\u003e\n\u003cli\u003e然后考虑在窗口移动的时候，怎样删除一些无用的元素。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果不开O2优化，那么数组比STL快一些。\u003c/p\u003e\n\u003cp\u003eO3优化\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#pragma GCC optimize(2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_500x0_resize_box_3.png 500w\" width=\"1004\" height=\"432\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img3_hu9dce7192a3a6a38dfbd3db2c7bfeab61_63441_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img3.png\" width=\"1004\" height=\"432\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint a[N], q[N];\n//q是下标，也就是队列，a只是记录的值a[q[i]]是取下标的值。\nint n, k;\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\n    for(int i = 0; i \u0026lt; n; ++ i)\n    {\n        scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n    }\n    \n    \n    int hh = 0, tt = -1;\n    for(int i = 0; i \u0026lt; n; i ++)\n    {\n        //判断队头是否已经出窗口\n        if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh])\n        {\n            ++ hh;\n        }\n        \n        //形成一个单调递增的序列。\n        while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i])\n            tt --;\n        q[++tt] = i;\n        if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]);\n    }\n    \n    puts(\u0026quot;\u0026quot;);\n    hh = 0, tt = -1;\n    for(int i = 0; i \u0026lt; n; ++ i)\n    {\n        if( hh \u0026lt;= tt \u0026amp;\u0026amp; i - q[hh] + 1 \u0026gt; k)\n            ++ hh;\n        while( hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i])\n            tt --;\n         q[++tt] = i;\n        if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]);\n       \n    }   \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"kmp\"\u003eKMP \u003ca href=\"#kmp\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e暴力算法怎么做？\u003c/li\u003e\n\u003cli\u003e如何去优化。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e朴素算法：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eS[N]→ p[M]\nfor(int  i = 1; i ≤ n; ++i)\u003c/p\u003e\n\u003cp\u003ebool flag = true;\u003c/p\u003e\n\u003cp\u003eint t = i;\u003c/p\u003e\n\u003cp\u003efor(int j = 1; j ≤ m; j++, t++)\u003c/p\u003e\n\u003cp\u003eif (s[t] ≠ p[j])\u003c/p\u003e\n\u003cp\u003e{\u003c/p\u003e\n\u003cp\u003eflag = false;\u003c/p\u003e\n\u003cp\u003ebreak;\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eKMP解释（以1开始）\u003c/p\u003e\n\u003cp\u003enext数组表示，next[i] = j，表示p[1, j] = p[ i - j  + 1, i]\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_500x0_resize_box_3.png 500w\" width=\"750\" height=\"440\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img4_huf88eacab1919db3b17c81887e2db2d54_125518_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img4.png\" width=\"750\" height=\"440\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_500x0_resize_box_3.png 500w\" width=\"1044\" height=\"678\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img5_hue72649ef51ee83b37f5682f830859873_219017_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img5.png\" width=\"1044\" height=\"678\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_500x0_resize_box_3.png 500w\" width=\"1026\" height=\"802\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img6_hu9bd3301078d94ea48ad657a848e9dc39_244071_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img6.png\" width=\"1026\" height=\"802\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010, M = 1000010;\n\nint n, m;\nchar p[N], s[M];\nint ne[N];\n\nint main() {\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; \n    //index from 1    \n    \n    // 求Next\n    for(int i = 2, j = 0; i \u0026lt;= n; ++ i)\n    {\n//每次都比较 j+1与i，到最后之前，可以保证1-j已经是匹配的。除非j = 0\n        while(j \u0026amp;\u0026amp; p[i] != p[ j + 1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n        //前j个（1-j）的元素与[i-j +1, i]的元素匹配，所以ne[i] = j\n    }\n    \n    \n    for(int i = 1, j = 0; i \u0026lt;=m ; ++ i)\n    {\n        while(j \u0026amp;\u0026amp; s[i] != p[ j + 1]) j = ne[j];\n        \n        if( s[i] == p[j+1]) j++;\n        if(j == n)//前n个元素已经匹配\n        {\n            //匹配成功\n            printf(\u0026quot;%d \u0026quot;, i - n );\n            j = ne[j];\n        }\n    }\n    \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"trie树\"\u003eTrie树 \u003ca href=\"#trie%e6%a0%91\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e高效地存储和查找字符串，集合的数据结构\u003c/p\u003e\n\u003cp\u003e比如：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eabcdef\nabdef\naced\nbcdf\nbcff\ncdaa\ndcdc\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e当数量过大，可以使用二进制来表示。比如考虑汉字，直接找其二进制100000101010,每一步仅考虑1和0.\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_500x0_resize_box_3.png 500w\" width=\"1100\" height=\"486\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img7_hua06694bdefb3606fc73f4789b0bad6a6_117292_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img7.png\" width=\"1100\" height=\"486\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint son[N][26], cnt[N], idx;\n//下标是0的点，既是根节点，又是空节点\nchar str[N];\n\nvoid insert(char str[])\n{\n    int p = 0;\n    for(int i = 0; str[i]; ++i){\n        int u = str[i] - 'a';   \n        if (!son[p][u]) son[p][u] = ++ idx;\n        p = son[p][u];\n    }\n    cnt[p] ++;\n}\n\nint query(char str[])\n{\n    int p = 0;\n    for(int i = 0; str[i]; ++i)\n    {\n        int u = str[i] - 'a';\n        if(!son[p][u]) return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}\n\nint main()\n{\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    while(n--)\n    {\n        char op[2];\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; str;\n        if (op[0] == 'I') insert(str);\n        else cout \u0026lt;\u0026lt; query(str) \u0026lt;\u0026lt; endl;\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"并查集\"\u003e并查集 \u003ca href=\"#%e5%b9%b6%e6%9f%a5%e9%9b%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e面试和比赛，非常容易出的数据结构。\u003c/p\u003e\n\u003cp\u003e用来快速的处理：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将两个集合合并\u003c/li\u003e\n\u003cli\u003e询问两个元素是否在一个集合当中\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ebelong[x] = a，存储x属于集合a。\u003c/p\u003e\n\u003cp\u003e近乎O（1）的支持上面的两个操作。\u003c/p\u003e\n\u003cp\u003e\u003cimg class=\"img-fluid lazyload blur-up\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img8_hu882418cb04ef9e711e5f1c8926c91121_35833_20x0_resize_box_3.png\" data-src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img8.png\" width=\"256\" height=\"404\" alt=\"Untitled\"\u003e\n\u003c/p\u003e\n\u003cp\u003e基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示父节点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e问题1： 如何判断树根 p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e == x, x就是集合的编号\u003c/li\u003e\n\u003cli\u003e问题2：如何求x的集合编号，while(p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e ! = x) x = p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e \u003c/li\u003e\n\u003cli\u003e问题3：如何合并两个集合：假设px是x的集合的编号，py是y的集合的编号，那么p\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e = y;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_500x0_resize_box_3.png 500w\" width=\"904\" height=\"276\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img9_hu524d49c81f0da3505709855275552235_55795_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img9.png\" width=\"904\" height=\"276\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e并查集的优化：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e（路径压缩）, 每次查询其父节点，只要直接指向其祖宗节点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e合并集合\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.acwing.com/problem/content/838/\"\u003ehttps://www.acwing.com/problem/content/838/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint p[N];\nint n, m;\n\nint find(int x) //返回x的祖宗节点，加上路径压缩\n{\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for(int i = 1; i \u0026lt;=n ; ++ i) p[i] = i;\n    \n    while(m --)\n    {\n        char op[2];\n//建议读入一个字符，也要使用字符串，自动过滤空格和回车\n        int a, b;\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n        if(op[0] == 'M') p[find(a)] = find(b);\n        else {\n            if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        }\n    }\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e连通块中点的数量\u003ca href=\"https://www.acwing.com/problem/content/839/\"\u003ehttps://www.acwing.com/problem/content/839/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\n//如何查询每个联通块的数量？维护根节点的size即可。\nint p[N], siz[N];\nint n, m;\n\nint find(int x) //返回x的祖宗节点，加上路径压缩\n{\n    if(p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for(int i = 1; i \u0026lt;=n ; ++ i) {\n        p[i] = i;\n        siz[i] = 1;\n    }\n    \n    while(m --)\n    {\n        char op[5];\n//建议读入一个字符，也要使用字符串，自动过滤空格和回车\n        int a, b;\n        cin \u0026gt;\u0026gt; op;\n        if(op[0] == 'C')\n        {\n            cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n            if(find(a) != find(b))\n                siz[find(b)] += siz[find(a)];\n            p[find(a)] = find(b);\n            \n        } else if (op[1] == '1')\n        {\n            cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\n            if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        } else\n        {\n            cin \u0026gt;\u0026gt; a;\n            cout \u0026lt;\u0026lt; siz[find(a)] \u0026lt;\u0026lt; endl;\n        }\n        \n    }\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"堆\"\u003e堆 \u003ca href=\"#%e5%a0%86\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e如何手写一个堆？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e插入一个数\u003c/li\u003e\n\u003cli\u003e求集合当中的最小值\u003c/li\u003e\n\u003cli\u003e删除最小值\u003c/li\u003e\n\u003cli\u003e删除任意一个元素\u003c/li\u003e\n\u003cli\u003e修改任意一个元素\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e堆的基本结构：\u003c/p\u003e\n\u003cp\u003e是一棵二叉树。是一棵完全二叉树。\u003c/p\u003e\n\u003cp\u003e以小顶堆为例，每个节点的左右子节点都大于该节点的值。\u003c/p\u003e\n\u003cp\u003e使用一个一维数组存放堆。\u003c/p\u003e\n\u003cp\u003e1号点是根节点，x的左儿子是2x，右子节点是2x+1。\u003c/p\u003e\n\u003cp\u003e操作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edown(x)，往下调整x。每次找这个节点和两个子节点的最小值，然后交换即可。\u003c/li\u003e\n\u003cli\u003eup(x)，往上调整x。每次往上和父节点比较，需要交换时交换即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e怎么插入x？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[ ++ idx] = x; up(x);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最小值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e删除最小值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[1] = heap[idx]; idx—; down(1);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e删除任意元素\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[k] = heap[size], size—; down(k); up(k);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e修改元素：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eheap[k] = x; down(k); up(k);\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n, m;\nint h[N], idx;\n\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2;\n    if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1;\n    \n    if(u!=t){\n        swap(h[u], h[t]);\n        down(t);\n    }\n}\n\nvoid up(int u)\n{\n    while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u])\n    {\n        swap(h[u/2], h[u]);\n        u/=2;\n    }   \n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    \n    for(int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;h[i]);\n    idx = n;\n    \n    for(int i = n/2; i ; -- i) down(i);\n    /*这是建立堆的过程\n    为什么从n/2开始down？\n    n/2的子孩子是最后一个元素，是完全二叉树的倒数第二层，所以这样一直递归\n    的做就好，而且时间复杂度是O(n);\n    */\n    \n    while(m--)\n    {\n        printf(\u0026quot;%d \u0026quot;, h[1]);\n        h[1] = h[idx];\n        idx --;\n        down(1);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e带映射版的堆操作:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.acwing.com/problem/content/841/\"\u003ehttps://www.acwing.com/problem/content/841/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n;\nint h[N], ph[N], hp[N], idx;\n//ph存放插入的第k个元素在堆的下标位置\n//hp存放的是堆中第j个元素在ph数组的位置索引。\n//ph和hp是互为反函数。\n\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]], ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2;\n    if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1;\n    \n    if(u!=t){\n        heap_swap(u, t);\n        down(t);\n    }\n}\n\nvoid up(int u)\n{\n    while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u])\n    {\n        heap_swap(u/2, u);\n        u/=2;\n    }   \n}\n\nint main()\n{\n    cin \u0026gt;\u0026gt; n;\n    int m = 0;\n    //m是第m个插入的元素。\n    while(n --)\n    {\n        char op[10];\n        int k, x;\n        cin \u0026gt;\u0026gt; op;\n        if (!strcmp(op, \u0026quot;I\u0026quot;))\n        {\n            cin \u0026gt;\u0026gt; x;\n            idx ++;\n            m ++;\n            ph[m] = idx;\n            hp[idx] = m;\n            h[idx] = x;\n            up(idx);\n        }\n        else if (!strcmp(op, \u0026quot;PM\u0026quot;)) cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; endl;\n        else if (!strcmp(op, \u0026quot;DM\u0026quot;))\n        {\n            heap_swap(1, idx);\n            idx --;\n            down(1);\n        }\n        else if(!strcmp(op, \u0026quot;D\u0026quot;))\n        {\n            cin \u0026gt;\u0026gt; k;\n            k = ph[k];\n            heap_swap(k, idx);\n            idx --;\n            down(k), up(k);\n        } else \n        {\n            cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x;\n            k = ph[k];\n            h[k] = x;\n            down(k), up(k);\n        }\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efind()和cnt()可以改成，get()和cnt()保证不编译错误，compile ERROR。\u003c/p\u003e\n\u003ch1 id=\"hash表\"\u003eHash表 \u003ca href=\"#hash%e8%a1%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e哈希表的存储结构，认为是O(1). 如果要删除，只要开个数组标记一下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e开放寻址法\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e拉链法\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_500x0_resize_box_3.png 500w\" width=\"1056\" height=\"348\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img10_hue02269398f091927dd5e6221f9baf572_104063_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img10.png\" width=\"1056\" height=\"348\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e常见情景： 把0-10^9的数映射到0-10^5的数组。\u003c/p\u003e\n\u003cp\u003ex mod 10 ^ 5 附近的质数。然后处理冲突。100003.\u003c/p\u003e\n\u003cp\u003e和离散化比较，离散是需要保序的。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e常用的字符串的哈希方式。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e//拉链法\n#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;//有memset\n\nusing namespace std;\n\nconst int N = 100003;\n//取大于10万的最小的质数。\n\nint h[N], e[N], ne[N], idx;\n\nvoid insert(int x)\n{\n    int k = (x % N + N) % N; //因为有的数是负数。\n    \n    e[idx] = x;\n    //e存值\n    ne[idx] = h[k];\n    //ne存指针\n    h[k] = idx;\n    idx ++;\n    //插入头部。\n}\n\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    for(int i = h[k]; i != -1; i = ne[i])\n    {\n        if(e[i] == x)\n            return true;\n    }\n    return false;\n}\n\nint main(){\n    int n;\n    \n    memset(h, -1, sizeof h);\n    \n    cin \u0026gt;\u0026gt; n;\n    while(n --)\n    {\n        char op[2];\n        int x;\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x;\n        \n        if(op[0] == 'I') insert(x);\n        else {\n            if (find(x)) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        }\n    }\n        \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_500x0_resize_box_3.png 500w\" width=\"528\" height=\"290\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img11_hu72b8828c0c4c914e71993c9d458a3870_85855_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img11.png\" width=\"528\" height=\"290\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e//开放寻址法\n#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\n//0xf3f3f3f3是10^9级别，很大，用来初始化数组\nconst int N = 2e5 + 3, null = 0x3f3f3f3f;\n//一般取三倍。\n//取质数。\nint h[N];\n\nint find(int x)\n{\n    int k = (x % N + N) % N;\n \n    while(h[k] != null \u0026amp;\u0026amp; h[k] != x)\n    {\n        k ++;\n        if(k == N) k = 0;\n    }\n    //这个过程一定会停止的，因为总共只有1e5个数字，而N是二倍，所以不担心满;\n    //结束条件时，h[k] == null 或 h[k] == x\n    return k;\n}\n\nint main(){\n    int n;\n    cin \u0026gt;\u0026gt; n;\n    \n    memset(h, 0x3f, sizeof h);\n    \n    while(n --)\n    {\n        char op[2];\n        int x;\n        cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x;\n        \n        int k = find(x);\n        if (op[0] == 'I')\n        {\n            h[k] = x;\n        } \n        else\n        {\n            if (h[k] != null) puts(\u0026quot;Yes\u0026quot;);\n            else puts(\u0026quot;No\u0026quot;);\n        }\n        \n    }\n    \n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e字符串前缀哈希法。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003estr = \u0026ldquo;ABCDEF\u0026rdquo;\nh[1] = \u0026ldquo;A\u0026rdquo; // 前1个\nh[2] = \u0026ldquo;AB\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e即处理前缀的hash，h[0] = 0\u003c/p\u003e\n\u003cp\u003e如果对字符串进行哈希？当成p进制数，a * p ^ 3 + b * p * 2 ……;再取模Q。\u003c/p\u003e\n\u003cp\u003e不能把字母映射成0.\u003c/p\u003e\n\u003cp\u003e\u003cfigure class=\"figure\"\u003e\n    \u003cimg class=\"figure-img img-fluid lazyload blur-up\" data-sizes=\"auto\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_20x0_resize_box_3.png\" data-srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_500x0_resize_box_3.png 500w\" width=\"729\" height=\"352\" alt=\"Untitled\"\u003e\n    \u003cnoscript\u003e\u003cimg class=\"figure-img img-fluid\" sizes=\"100vw\" srcset=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_900x0_resize_box_3.png 900w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_800x0_resize_box_3.png 800w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_700x0_resize_box_3.png 700w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_600x0_resize_box_3.png 600w,https://notes.ming.ac/docs/algorithm/algorithm_02/img12_hu6addbfa552702c42f6831685306972d5_118345_500x0_resize_box_3.png 500w\" src=\"https://notes.ming.ac/docs/algorithm/algorithm_02/img12.png\" width=\"729\" height=\"352\" alt=\"Untitled\"\u003e\u003c/noscript\u003e\n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e那么前缀哈希值有什么用呢？因为我们已经知道 h[L]到h[R]的哈希值\u003c/p\u003e\n\u003cp\u003e所以求L - R的哈希值，只要 h[R] - h[L - 1] * p ^ {R-L+1};\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nconst int N = 100010, P = 131; \n\nint n, m;\nchar str[N];\nULL h[N], p[N];\n//p是存放P的n次方\n\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\nint main(){\n    \n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; str + 1;\n    \n    p[0] = 1;\n    for(int i = 1; i \u0026lt;= n; ++ i)\n    {\n        p[i] = p[i - 1] * P;\n        h[i] = h[i - 1] * P + str[i];\n    }\n    \n    while( m --)\n    {\n        int l1, r1, l2, r2;   \n        cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2;\n        if(get(l1, r1) == get(l2, r2))\n        {\n            puts(\u0026quot;Yes\u0026quot;);   \n        } else {\n            puts(\u0026quot;No\u0026quot;);   \n        }\n        \n    }\n    \n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehash算法求两个字符串相同比KMP更好\u003c/p\u003e\n\u003cp\u003eKMP更适合循环节。\u003c/p\u003e\n\u003ch1 id=\"cstl使用\"\u003eC++STL使用 \u003ca href=\"#cstl%e4%bd%bf%e7%94%a8\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003evector 可变长数组，倍增的思想\nstring 处理字符串的利器，substr(), c_str()\nqueue, 队列，进行push(),front(), pop()\npriority_queue，优先队列，堆，push(), top(), pop()\nstack 栈，Push(), top(), pop()\n\ndeque 双端队列\n\nset, map, multiset, multimap 基于平衡二叉树（红黑树）动态维护有序序列\nunordered_set, unordered_map, unordered_multiset, unordered_multimap 哈希表\nbitset;压位\n\nlist用的不多。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"vector\"\u003evector: \u003ca href=\"#vector\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;vector\u0026gt;\n\nusing namespace std;\n\nint main()\n{\n    vector\u0026lt;int\u0026gt; a(10, 3);\n    vector\u0026lt;int\u0026gt; b[10]; //定义数组\n    //定义一个长度为10的，初始值为3的vector\n    //for(auto x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;\n    \n    a.size(); //O(1)\n    a.empty(); \n    \n    a.clear();//清空\n    /*系统分配空间时，所需时间与空间大小无关，与申请次数有关！！！\n    所以尽量减少申请空间的次数。\n    vector最初分配32的空间，然后如果不够，分配64，然后copy过去之前的元素。\n    申请长度为2 ^ n的数组，那么需要copy(1 + 2 + 2^n-1) = 2^n可以认为是O(1)\n    申请空间的次数是log(2^n) = n\n    */\n    \n    a.front();\n    a.back();\n    a.push_back();\n    a.pop_back();\n    begin();\n    end();\n    [];\n    \n\t\ta \u0026lt; b可以判断两个vector的大小，按字典序比。\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"下面是模板\"\u003e下面是模板 \u003ca href=\"#%e4%b8%8b%e9%9d%a2%e6%98%af%e6%a8%a1%e6%9d%bf\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eC++ STL简介\nvector, 变长数组，倍增的思想\n    size()  返回元素个数\n    empty()  返回是否为空\n    clear()  清空\n    front()/back()\n    push_back()/pop_back()\n    begin()/end()\n    []\n    支持比较运算，按字典序\n\npair\u0026lt;int, int\u0026gt;p;\n    first, 第一个元素\n    second, 第二个元素\n    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\t\tp = make_pair(10, 2);\n\t\tp = {10, 2};\n\t\tpair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;p;存三个\n\nstring，字符串\n    size()/length()  返回字符串长度\n    empty()\n    clear()\n    substr(起始下标，(子串长度))  返回子串\n    c_str()  返回字符串所在字符数组的起始地址\n\t\t\t\t用于用printf输出\n\t\t支持加运算：\n\t\t\t\tstring a = \u0026quot;1\u0026quot;;\n\t\t\t\ta += \u0026quot;bcd\u0026quot;;\n\nqueue, 队列\n    size()\n    empty()\n    push()  向队尾插入一个元素\n    front()  返回队头元素\n    back()  返回队尾元素\n    pop()  弹出队头元素\n\npriority_queue, 优先队列，默认是大顶堆\n    size()\n    empty()\n    push()  插入一个元素\n    top()  返回堆顶元素\n    pop()  弹出堆顶元素\n    定义成小顶堆的方式：\n\t\t\t\tpriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q;\n\t\t\n\t\tpriority_queue\u0026lt;int\u0026gt; heap;\n\t\t\t\t可以通过插入-x实现小顶堆。\n\nstack, 栈\n    size()\n    empty()\n    push()  向栈顶插入一个元素\n    top()  返回栈顶元素\n    pop()  弹出栈顶元素\n\ndeque, 双端队列，加强版vector，效率低，尽量不用\n    size()\n    empty()\n    clear()\n    front()/back()\n    push_back()/pop_back()\n    push_front()/pop_front()\n    begin()/end() 迭代器\n    [] 支持直接索引\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\n    size()\n    empty()\n    clear()\n    begin()/end()\n    ++, -- 返回前驱和后继，时间复杂度 O(logn)\n\n    set/multiset\n\t\t\t\tset不允许重复元素\n        insert()  插入一个数\n        find()  查找一个数，返回迭代器，找不到返回end迭代器\n        count()  返回某一个数的个数\n        erase()\n            (1) 输入是一个数x，删除所有x   O(k + logn)\n            (2) 输入一个迭代器，删除这个迭代器\n        lower_bound()/upper_bound()\n            lower_bound(x)  返回大于等于x的最小的数的迭代器\n            upper_bound(x)  返回大于x的最小的数的迭代器\n    map/multimap\n        insert()  插入的数是一个pair\n        erase()  输入的参数是pair或者迭代器\n        find()\n        []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n        lower_bound()/upper_bound()\n\t\t\t\t\n\t\t\t\tmap\u0026lt;string ,int\u0026gt; a;\n\t\t\t\ta[\u0026quot;yxc\u0026quot;] = 1;\n\t\t\t\tcout \u0026lt;\u0026lt; a[\u0026quot;yec\u0026quot;] \u0026lt;\u0026lt; endl;\n\t\t\t\t\nunordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()/upper_bound()， 迭代器的++，--.\n\nbitset, 圧位\n\t\t是bool数组的1/8。🐂\n    bitset\u0026lt;10000\u0026gt; s; \n\t\t~s;\n\n    ~, \u0026amp;, |, ^\n    \u0026gt;\u0026gt;, \u0026lt;\u0026lt;\n    ==, !=\n    []\n\n    count()  返回有多少个1\n\n    any()  判断是否至少有一个1\n    none()  判断是否全为0\n\n    set()  把所有位置成1\n    set(k, v)  将第k位变成v\n    reset()  把所有位变成0\n    flip()  等价于~\n    flip(k) 把第k位取反\n\n作者：yxc\n链接：https://www.acwing.com/blog/content/404/\n来源：AcWing\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 2,
        href: "https://notes.ming.ac/docs/prologue/introduction/",
        title: "Introduction",
        description: "Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",
        content: "\u003ch2 id=\"get-started\"\u003eGet started \u003ca href=\"#get-started\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eStep-by-step instructions on how to start a new Doks project. \u003ca href=\"https://getdoks.org/tutorial/introduction/\"\u003eTutorial →\u003c/a\u003e\u003c/p\u003e\n"
      },
    {
        id: 3,
        href: "https://notes.ming.ac/docs/prologue/commands/",
        title: "Commands",
        description: "Doks comes with commands for common tasks.",
        content: "\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003e💡 \u003c/div\u003e\n  \n    \u003cdiv class=\"w-100\"\u003eYou can change the commands in the scripts section of `./package.json`. \u003c/div\u003e\n  \n\u003c/div\u003e\n\n\u003ch2 id=\"create\"\u003ecreate \u003ca href=\"#create\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCreate new content for your site:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run create [path] [flags]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSee also the Hugo docs: \u003ca href=\"https://gohugo.io/commands/hugo_new/\"\u003ehugo new\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"lint\"\u003elint \u003ca href=\"#lint\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCheck scripts, styles, and markdown for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"scripts\"\u003escripts \u003ca href=\"#scripts\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCheck scripts for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint:scripts [-- --fix]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"styles\"\u003estyles \u003ca href=\"#styles\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCheck styles for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint:styles [-- --fix]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"markdown\"\u003emarkdown \u003ca href=\"#markdown\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCheck markdown for errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run lint:markdown [-- --fix]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"clean\"\u003eclean \u003ca href=\"#clean\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDelete temporary directories:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run clean\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"start\"\u003estart \u003ca href=\"#start\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eStart local development server:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run start\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"build\"\u003ebuild \u003ca href=\"#build\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eBuild production website:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run build\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"functions\"\u003efunctions \u003ca href=\"#functions\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBuild Lambda functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run build:functions\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"preview\"\u003epreview \u003ca href=\"#preview\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBuild production website including draft and future content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm run build:preview\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
    {
        id: 4,
        href: "https://notes.ming.ac/docs/prologue/",
        title: "Prologue",
        description: "Prologue Doks.",
        content: ""
      },
    {
        id: 5,
        href: "https://notes.ming.ac/docs/algorithm/",
        title: "al",
        description: "Docs Doks.",
        content: ""
      },
    {
        id: 6,
        href: "https://notes.ming.ac/docs/",
        title: "Docs",
        description: "Docs Doks.",
        content: ""
      },
    ];
  */

  // https://discourse.gohugo.io/t/range-length-or-last-element/3803/2

  index.add(
    {
        id: 0,
        href: "/docs/algorithm/algorithm_01/",
        title: "「Algorithm」01 基础算法",
        description: "排序 二分 高精度 前缀和与差分 位运算 离散化 区间合并  消除同步 #  ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。 scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。 可以使用freopen  还可以加上 cin.tie(0) 来解除c++运行库层面的对数据传输的绑定。\n排序 # 1. 快速排序 # 基于分治。\n 确定一个分界点，比如（以1开始）,取q[1]，q[(1+r)/2] ,q[r]， 随机为x 调整区间，小于等于x的在左边，大于等于x的在右边。等于x的可以在左边也可以在右边，也可以在边界上，不稳定。 递归处理左右两段。    方法一:\n 开两个额外的数组,a[]，b[] 扫描q数组，如果q[i] ≤ x，存入a，如果q[i]\u0026gt;x，存入b。 然后将a数组的数存入q，b数组的数存入q。    方法二：\n i和j指针，i指向初始，j指向末尾。然后i向右走，直到遇到一个大于x的数。j向左走，直到遇到一个小于等于x的数。然后交换，直到 j ≤ i.  模板：\n#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int x = q[(l+r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while( i \u0026lt; j){ do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j ) swap(q[i],q[j]); } //j可能比i小，也可能等于i。 quick_sort(q, l, j); //也可以换成 l, i -1 quick_sort(q, j + 1, r); //换成 i, r //后来说明不能换成i，因为也是会出现死循环问题。 //遇到这种情况，就考虑0,1。 //用j的话，x不能取右边界，（j可以取q[l]、q[(l+r)/2]） //j不能取 q[r]、q[(l+r+1)/2] //用i的话，x不能取左边界。 (i可以取q[r]、q[(l+r+1)/2]) //i不能取 q[l]、q[(l+r)/2] } //当下面换成i,r时，不能取x=q[l]，因为会出现死循环的问题。比如排序1，2 //i最终为0，j也是0，这样使用quick_sort()会死循环。 //同理，如果取j+1,r，不能取右边界。 int main(){ scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); for(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026quot;%d\u0026quot;,\u0026amp;q[i]); quick_sort(q,0,n-1); for(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026quot;%d \u0026quot;,q[i]); return 0; } 排序的话，可以使用 #include\u0026lt;algorithm\u0026gt; sort(q, q+n);    2.",
        content: " 排序 二分 高精度 前缀和与差分 位运算 离散化 区间合并  消除同步 #  ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。 scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。 可以使用freopen  还可以加上 cin.tie(0) 来解除c++运行库层面的对数据传输的绑定。\n排序 # 1. 快速排序 # 基于分治。\n 确定一个分界点，比如（以1开始）,取q[1]，q[(1+r)/2] ,q[r]， 随机为x 调整区间，小于等于x的在左边，大于等于x的在右边。等于x的可以在左边也可以在右边，也可以在边界上，不稳定。 递归处理左右两段。    方法一:\n 开两个额外的数组,a[]，b[] 扫描q数组，如果q[i] ≤ x，存入a，如果q[i]\u0026gt;x，存入b。 然后将a数组的数存入q，b数组的数存入q。    方法二：\n i和j指针，i指向初始，j指向末尾。然后i向右走，直到遇到一个大于x的数。j向左走，直到遇到一个小于等于x的数。然后交换，直到 j ≤ i.  模板：\n#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int x = q[(l+r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while( i \u0026lt; j){ do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j ) swap(q[i],q[j]); } //j可能比i小，也可能等于i。 quick_sort(q, l, j); //也可以换成 l, i -1 quick_sort(q, j + 1, r); //换成 i, r //后来说明不能换成i，因为也是会出现死循环问题。 //遇到这种情况，就考虑0,1。 //用j的话，x不能取右边界，（j可以取q[l]、q[(l+r)/2]） //j不能取 q[r]、q[(l+r+1)/2] //用i的话，x不能取左边界。 (i可以取q[r]、q[(l+r+1)/2]) //i不能取 q[l]、q[(l+r)/2] } //当下面换成i,r时，不能取x=q[l]，因为会出现死循环的问题。比如排序1，2 //i最终为0，j也是0，这样使用quick_sort()会死循环。 //同理，如果取j+1,r，不能取右边界。 int main(){ scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); for(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026quot;%d\u0026quot;,\u0026amp;q[i]); quick_sort(q,0,n-1); for(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026quot;%d \u0026quot;,q[i]); return 0; } 排序的话，可以使用 #include\u0026lt;algorithm\u0026gt; sort(q, q+n);    2.归并排序 # 类似快排，也是分治。\n 以中间点为分界点。 递归排序左边和右边。 归并左右两个有序的数组为1个有序的数组。  对两个数组，取两个指针指向数组的左端点。然后比较他们的值，取较小者，然后移动指针，接着继续比较，直到一个指针到头，然后将另一个数组的剩余值取走。 当指针指向的值相同时，取左边数组的值，保持稳定，这说明归并排序是稳定的。快排是不稳定的。而让快排稳定的话，可以用pair。    为什么归并排序是O(nlogn),怎么分析？\n归并排序总共有logn层，每层都是O(n)，所以是O(nlogn)\n  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int n; int q[N], tmp[N]; void merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; //+优先级比\u0026gt;\u0026gt;大，可以不加括号 merge_sort(q, l, mid), merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while ( i \u0026lt;= mid) tmp[k++] = q[i++]; while ( j \u0026lt;= r) tmp[k++] = q[j++];\tfor ( i = l, j = 0; i \u0026lt;= r; i++, j++) q[i] = tmp[j]; } int main(){ scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); for(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026quot;%d\u0026quot;,\u0026amp;q[i]); merge_sort(q, 0, n-1); for(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026quot;%d \u0026quot;,q[i]); return 0; }  二分 # 1. 整数二分 # 模板：\n// 区间[l,r]被划分为[l,mid]与[mid + 1,r]时用 int bsearch_1(int l, int r) { while( l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r= mid; //check判断mid是否满足性质 else l = mid + 1; } return l; } //区间[l,r]被划分成[l, mid - 1]和[mid, r]时使用。 int bsearch_2(int l, int r){ while(l \u0026lt; r) {\tint mid = l + r + 1 \u0026gt;\u0026gt; 1; if(check(mid)) l = mid; else r = mid -1; } return l; }   二分的本质：寻找区间的边界。边界的左边满足某种性质，边界的右边满足另一种性质。     mid = (l+r+1)/2 找红色的边界点,检测中间值是否满足check。  check检查是否满足红色。 if mid满足check，那么需要向右找，那么 l = mid; [mid, r] if mid不满足check，那么需要向左找，那么r = mid -1：[l , mid - 1]   mid = (l + r)/ 2寻找绿色的边界点。check检测是否满足绿色。  if mid 满足 check, 那么需要向左找，那么 r = mid; [l , mid] if mid 不满足 check, 那么需要向右找，那么 l = mid + 1; [mid + 1, r]    为什么第一个需要mid = (l + r + 1)/2 ，因为如果r = l + 1，如果不加一，那么mid = l，区间的更新为：[l,r] 和[l,l]，陷入了死循环。\n所以总的来说，我们如何使用上面两个？\n1，2，2，3，3，4。\n找3的起始坐标和终止坐标。\n//https://www.acwing.com/problem/content/791/ #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n,m; int q[N]; int main(){ scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); for(int i = 0; i \u0026lt; n; i++ ) scanf(\u0026quot;%d\u0026quot;, \u0026amp;q[i]); while(m--){ int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); int l = 0, r = n -1; while ( l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (q[mid] \u0026gt;= x){ //找起始坐标 r = mid; } else l = mid + 1; } // l == r if (q[l] != x) cout \u0026lt;\u0026lt; \u0026quot;-1 -1\u0026quot; \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026quot; \u0026quot;; int l = 0, r = n - 1; while (l \u0026lt; r){ int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (q[mid] \u0026lt;= x) l = mid; // l =mid，需要 l+r+1 \u0026gt;\u0026gt; 1 else r = mid - 1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; } } return 0; }  2. 浮点数二分 # #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ double x; cin \u0026gt;\u0026gt; x; double l = 0, r= x; while( r - l \u0026gt; 1e-6){ //1e8 double mid = (l+r)/2; if (mid * mid \u0026gt;= x) r = mid; else l = mid; } /* 迭代100次; for (int i = 0; i \u0026lt; 100; i++){ double mid = (l+r)/2; if (mid * mid \u0026gt;= x)\tr = mid; else l = mid; } */\tprintf(\u0026quot;%lf\\n\u0026quot;, l); return 0; } //保留几位小数，增加2有效位。保留2位，1e-4  三次方根：\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int main(){ double x; cin \u0026gt;\u0026gt; x; double l = -1000, r= 1000; while( r - l \u0026gt; 1e-8){ double mid = (l+r)/2; if (mid * mid *mid \u0026gt;= x) r = mid; else l = mid; } printf(\u0026quot;%lf\\n\u0026quot;, l); return 0; }  牛顿迭代法求平方根：a 是待求平方根的数\n$$x = \\frac{x^2_0+a}{2x_0}$$\n如何通俗易懂地讲解牛顿迭代法求开方？数值分析？ - 杨华的回答 - 知乎 https://www.zhihu.com/question/20690553/answer/15864267\n高精度 # 只有C++需要关注。Python默认数是无限大，Java有大整数BigInteger和BigDecimal。\n A + B A - B A * a len(A) ≤ 10^6 a ≤ 10^9 A / a 求商和余数  存储方法：比如 123456789\n 给一个数组a[9]，那么a[0] = 9，a[1] = 8，……a[8] = 1，数组的低位存数字的低位。  加法： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; const int N = 1e6 + 10; vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){ vector\u0026lt;int\u0026gt; C; int t = 0; //进位 for(int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i ++){ if (i \u0026lt; A.size()) t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } /* vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){ vector\u0026lt;int\u0026gt; C; if (A.size() \u0026lt; B.size()) return add(B,A); int t = 0; //进位 for(int i = 0; i \u0026lt; A.size(); i ++){ t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } */ int main(){ string a,b; vector\u0026lt;int\u0026gt; A,B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = a.size() - 1; i \u0026gt;= 0; i --) A.push_back(a[i] - '0'); for (int i = b.size() - 1; i \u0026gt;= 0; i --) B.push_back(b[i] - '0'); auto C = add(A,B); for (int i = C.size() - 1; i \u0026gt;= 0; i --) printf(\u0026quot;%d\u0026quot;,C[i]); return 0; }  如果每一个存放不止一位数字：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int base = 1000000000; vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % base); t /= base; } if (t) C.push_back(t); return C; } int main() { string a, b; vector\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = a.size() - 1, s = 0, j = 0, t = 1; i \u0026gt;= 0; i -- ) { s += (a[i] - '0') * t; j ++, t *= 10; if (j == 9 || i == 0) { A.push_back(s); s = j = 0; t = 1; } } for (int i = b.size() - 1, s = 0, j = 0, t = 1; i \u0026gt;= 0; i -- ) { s += (b[i] - '0') * t; j ++, t *= 10; if (j == 9 || i == 0) { B.push_back(s); s = j = 0; t = 1; } } auto C = add(A, B); cout \u0026lt;\u0026lt; C.back(); for (int i = C.size() - 2; i \u0026gt;= 0; i -- ) printf(\u0026quot;%09d\u0026quot;, C[i]); cout \u0026lt;\u0026lt; endl; return 0; } 作者：yxc 链接：https://www.acwing.com/activity/content/code/content/39792/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  减法： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; bool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B) { if (A.size() != B.size()) return A.size() \u0026gt; B.size(); for(int i = A.size() - 1 ; i \u0026gt;= 0; i--) if(A[i] != B[i]) return A[i] \u0026gt; B[i]; return true; } vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt;\u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){ vector\u0026lt;int\u0026gt; C; for (int i = 0, t =0; i \u0026lt; A.size(); ++ i){ t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); //数学，当t小于0，就可以+10，而如果t \u0026gt;=0， 就无影响； if ( t \u0026lt; 0) t = 1; //有借位 else t = 0; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main(){ string a,b; vector\u0026lt;int\u0026gt; A,B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i \u0026gt;= 0; -- i) B.push_back(b[i] - '0'); if (cmp(A,B)) { auto C = sub(A,B); for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]); } else { auto C = sub(B,A); printf(\u0026quot;-\u0026quot;); for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]); } return 0; }  乘法： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt;\u0026amp;A, int b){ vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size() || t; ++ i) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main(){ string a; int b; vector\u0026lt;int\u0026gt; A; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - '0'); auto C = mul(A,b); for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]); return 0; }  除法： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for(int i = A.size() - 1; i \u0026gt;= 0; -- i) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main(){ string a; int b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vector\u0026lt;int\u0026gt; A; for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - '0'); int r = 0; auto C = div(A, b, r); for(int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026quot;%d\u0026quot;, C[i]); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; }  前缀和 与 差分 # 前缀和与差分是逆运算。\n前缀和： #  一个长度为n的数组 然后前缀和数组,Si = 前i个数的和（从a1、a2到ai）。 定义$S_0 = 0$;  问题是如何求Si，求前i个和即可。\n！作用：求一段数字的和。比如求[l, r]，那么就是求\n$$S_r - S_{l-1}$$\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; int a[N], s[N]; int main(){ //ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。 //可以，但是scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。 //可以使用freopen。 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; ++ i) s[i] = s[i - 1] + a[i]; while(m --) { int l,r; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r); printf(\u0026quot;%d\\n\u0026quot;,s[r] - s[l - 1]); } return 0; }  二维前缀和 # 从$(x_1,y_1)\\ to \\ (x_2,y_2)$，的区域的面积。那么就是：\n$$S_{x_2y_2}-S_{x_2(y_1-1)}-S_{(x_1-1)y_2}+S_{(x_1-1)(y_1-1)}$$\n#include\u0026lt;iostream\u0026gt; using namespace std; int n, m, q; const int N = 1e3 + 10; int a[N][N], s[N][N]; int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++ i) for (int j = 1; j \u0026lt;= m; ++ j){ scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]); s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } while(q --){ int x1,y1,x2,y2; scanf(\u0026quot;%d%d%d%d\u0026quot;, \u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2); printf(\u0026quot;%d\\n\u0026quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1-1] + s[x1-1][y1-1]); } return 0; }  差分 # a数组是b数组的前缀和，b数组是a的差分。\n对于a1, a2, a3……an\n构造 b1, b2, b3, bn\n使得 aj = b1 + b2 + …… + bj\n用处：a和b数组在O（n）时间可以相互转化。\n让al到ar，[l, r]的数都加上c，用差分只要O(1)。只要让$b_l+c$，然后让 $b_{r+1}-c$\n可以假定a数组和b数组全是零，只要看插入操作，即在[1, 1]的数都加上a1, [2,2]的数都加上a2\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; ++ i) insert(i, i, a[i]); while(m --) { int l, r, c; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;l, \u0026amp;r, \u0026amp;c); insert(l, r, c); } for (int i = 1; i \u0026lt;= n; ++ i) { b[i] += b[i-1]; //求前缀和 printf(\u0026quot;%d \u0026quot;, b[i]); } return 0; }  差分矩阵 #   初始化时，也是可以相当于在(i, j)和(i, j)之间增加$a_{i,j}$\nb数组是a数组的差分，a数组是b数组的前缀和。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e3 + 10; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2+1] -=c; b[x2+1][y2+1] +=c; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++ i) for (int j = 1; j \u0026lt;= m; ++ j) scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i][j]); for (int i = 1; i \u0026lt;= n; ++ i) for (int j = 1; j \u0026lt;= m; ++ j) insert(i,j,i,j,a[i][j]); while(q --) { int x1,y1,x2,y2,c; scanf(\u0026quot;%d%d%d%d%d\u0026quot;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;c); insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; ++ i) { for (int j = 1; j \u0026lt;= m; ++ j){ b[i][j] += b[i -1][j] + b[i][j -1] - b[i- 1][j-1]; printf(\u0026quot;%d \u0026quot;, b[i][j]); } puts(\u0026quot;\u0026quot;); } return 0; }  双指针算法 # 包括归并排序\n  for(int i = 0, j = 0; i \u0026lt; n; ++ i){ while( j \u0026lt; i \u0026amp;\u0026amp; check(i, j)) ++ j; //具体逻辑 }  核心思想：把O(n^2)两重循环 变成 O(n).\n举个例子，输入一个句子，输出每个单词：\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int main() { char str[1000]; cin.getline(str, 1000); int n = strlen(str); for (int i = 0; i \u0026lt; n; ++ i) { int j = i; while( j \u0026lt; n \u0026amp;\u0026amp; str[j] !=' ') ++ j; for (int k = i; k \u0026lt; j; k ++) cout \u0026lt;\u0026lt; str[k]; cout \u0026lt;\u0026lt; endl; i = j; } return 0; }  799. 最长连续不重复子序列\ncheck检验是否有重复元素\n  //数据很大时可以用hash table来做 #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n; int a[N], s[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++ i ) scanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]); int res = 0; for (int i = 0, j = 0; i \u0026lt; n; ++ i ) { ++ s[a[i]]; while (j \u0026lt;= i \u0026amp;\u0026amp; s[a[i]] \u0026gt; 1) { -- s[a[j]]; ++ j; } res = max(res, i - j + 1); } cout \u0026lt;\u0026lt; res; return 0; }  位运算 # 第k位的值 #  n的二进制表示中，第k位是几？个位是第零位。  先把第k位移到最后一位， n \u0026raquo; k 再看个位是几。x \u0026amp; 1. 即 (n \u0026raquo; k) \u0026amp; 1，\u0026raquo;运算符的优先级大于 \u0026amp;，可以不加括号。    lowbit操作。 # 可以用来统计x中的1的数量。\nlowbit(x)，返回x的最后一位的1。\nLowbit( 1010) ——\u0026gt; 得到最后一个1。\n  -x = ~x + 1。 补码表示。 那么 x \u0026amp; -x = x \u0026amp; ( ~x + 1)  #include\u0026lt;iostream\u0026gt; using namespace std; int lowbit(int x) { return x \u0026amp; -x; } int main (){ int n; cin \u0026gt;\u0026gt; n; while(n--){ int x; cin \u0026gt;\u0026gt; x; int res = 0; while(x) x -= lowbit(x), ++ res; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } return 0; }  一个数 -x 的：\n原码：最高位取1.\n反码：各位取反\n补码：各位取反，加一。\n  离散化 # 整数的离散化：\n值域为$0-{10}^9$，个数有$10^5$。映射到0-n\n比如a[]: 1, 3, 100, 2000, 500000. 将它们映射到0，1，2，3，4，\n注意：\n a[]中可能有重复的元素，需要去重 如何算出a[i] 离散化后的值是多少？二分。    unique是将alls数组进行去重，将重复元素放在末尾，返回值是一个迭代器，指向非重复元素的最后一个，然后在删除这些元素就好。\n找到第一个≥ x的位置, 这个是边界问题。\n返回r+1是映射到1,2,……n\nUnique # 如何实现Unique函数？\n比如1 1 2 2 2 3 4 5 5 5 6\nvector\u0026lt;int\u0026gt;::iterator unique(vector\u0026lt;int\u0026gt; \u0026amp;a) { int j = 0; for(int i = 0; i \u0026lt; a.size(); ++ i ) { if (!i || a[i] != a[i-1]) a[j++] = a[i] } return a.begin() + j; }  区间和： # 如果数据比较小，就是前缀和和差分的问题。但是这个问题的数据量比较大，而且有负数。\n这个问题，是插入的数量比较小。虽然跨度有10亿个，但是查询和插入的数量都是十万不到。所以需要离散化。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n,m; int a[N], s[N]; vector\u0026lt;int\u0026gt; alls; vector\u0026lt;PII\u0026gt; add, query; int find(int x) { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; n; ++ i ) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x,c}); alls.push_back(x); } for(int i = 0; i \u0026lt; m; ++ i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back(make_pair(l,r)); alls.push_back(l); alls.push_back(r); } sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); for(auto item : add) { int x = find(item.first); a[x] += item.second; } for (int i = 1; i \u0026lt;= alls.size(); ++ i) s[i] = s[i - 1] + a[i]; for (auto item: query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } return 0; }  区间合并 # 把有重叠点的区间合并\n  #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; const int N = 200010; typedef pair\u0026lt;int, int\u0026gt; PII; vector\u0026lt;PII\u0026gt; segs; int n; void merge(vector\u0026lt;PII\u0026gt; \u0026amp; segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); //先排first，再排second int st = -2e9, ed = -2e9; //st = start, ed = end for(auto seg : segs) { if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else { ed = max(ed, seg.second); } } if (st != -2e9) res.push_back({st, ed}); segs = res; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++ i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; segs.push_back({l, r}); } merge(segs); cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl; return 0; }  "
      })
      .add(
      {
        id: 1,
        href: "/docs/algorithm/algorithm_02/",
        title: "「Algorithm」02 Data Structure",
        description: "链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 # 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\nstruct Node { int val; Node * next; }; Node * p = new Node();  面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 # 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n  以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == 'H') { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == 'D') { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i !",
        content: " 链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 # 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\nstruct Node { int val; Node * next; }; Node * p = new Node();  面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 # 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n  以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == 'H') { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == 'D') { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; return 0; }  用数组模拟双链表 # 用来优化某些问题。\nint l[N], r[N];，让0是head，1是tail\n  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int m; int e[N], l[N], r[N], idx; void init() { //0表示左端点，1表示右端点 r[0] = 1; l[1] = 0; idx = 2; } void add(int k, int x) { //在k的右边插入x e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++; //如果想插入左边，只要add(l[k], x) } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { cin \u0026gt;\u0026gt; m; }  邻接表，就是n个单链表.\n栈与队列 # 栈就是先进后出。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int stk[N], tt; int main() { 初始化 //tt = -1; 入栈 //stk[ ++ tt] = x; 出栈 // return stk[tt --]; 空 //if (tt \u0026gt;= 0) return true; //else return false; 栈顶 //stk[tt]; } 实际上，令tt = 0初始化，更简洁。 判空时，只要 if (tt \u0026gt; 0) return true; // if(tt) return true; else return false;  队列：\nint q[N], hh = 0, tt = -1; //hh是队头， tt是队尾。队尾插入，队头弹出 //插入 q[ ++ tt] = x; //弹出： return q[hh ++]; if( hh \u0026lt;= tt) not empty; else empty; 取出队头队尾元素： return q[hh]; return q[tt];  考验记忆力和毅力（自制力）。\n单调栈： # 给定一个序列，求序列中的每一个数，离他最近的左边比他小的数。否则为-1。\n我们设置一个栈，对于每个x，之前的元素，应该让stk[tt] ≥ x的都出栈。\n这样x再入栈，就是一个单调递增的栈序列。而找到最小的，只要找到x入栈前的栈顶即可。\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n; int stk[N], tt; int main() { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++ i) { int x; cin \u0026gt;\u0026gt; x; while(tt \u0026amp;\u0026amp; stk[tt] \u0026gt;= x) tt --; if (tt) cout \u0026lt;\u0026lt; stk[tt] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; stk[++tt] = x; } return 0; } //这个算法，每个元素都最多入栈和出栈一次，所以复杂度是O（n）  单调队列 # https://www.acwing.com/problem/content/156/滑动窗口\n一个序列，在一个窗口内，算出其最大值和最小值，窗口逐渐向右移动。\n在一个窗口内，如果右边的元素比左边的元素小，\n 首先考虑暴力怎么做。 然后考虑在窗口移动的时候，怎样删除一些无用的元素。  如果不开O2优化，那么数组比STL快一些。\nO3优化\n#pragma GCC optimize(2)    #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int a[N], q[N]; //q是下标，也就是队列，a只是记录的值a[q[i]]是取下标的值。 int n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; n; ++ i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); } int hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; i ++) { //判断队头是否已经出窗口 if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) { ++ hh; } //形成一个单调递增的序列。 while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]); } puts(\u0026quot;\u0026quot;); hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; ++ i) { if( hh \u0026lt;= tt \u0026amp;\u0026amp; i - q[hh] + 1 \u0026gt; k) ++ hh; while( hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026quot;%d \u0026quot;, a[q[hh]]); } }  KMP #  暴力算法怎么做？ 如何去优化。  朴素算法：\n S[N]→ p[M] for(int i = 1; i ≤ n; ++i)\nbool flag = true;\nint t = i;\nfor(int j = 1; j ≤ m; j++, t++)\nif (s[t] ≠ p[j])\n{\nflag = false;\nbreak;\n}\n KMP解释（以1开始）\nnext数组表示，next[i] = j，表示p[1, j] = p[ i - j + 1, i]\n      #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010, M = 1000010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; //index from 1 // 求Next for(int i = 2, j = 0; i \u0026lt;= n; ++ i) { //每次都比较 j+1与i，到最后之前，可以保证1-j已经是匹配的。除非j = 0 while(j \u0026amp;\u0026amp; p[i] != p[ j + 1]) j = ne[j]; if(p[i] == p[j+1]) j++; ne[i] = j; //前j个（1-j）的元素与[i-j +1, i]的元素匹配，所以ne[i] = j } for(int i = 1, j = 0; i \u0026lt;=m ; ++ i) { while(j \u0026amp;\u0026amp; s[i] != p[ j + 1]) j = ne[j]; if( s[i] == p[j+1]) j++; if(j == n)//前n个元素已经匹配 { //匹配成功 printf(\u0026quot;%d \u0026quot;, i - n ); j = ne[j]; } } return 0; }  Trie树 # 高效地存储和查找字符串，集合的数据结构\n比如：\n abcdef abdef aced bcdf bcff cdaa dcdc\n 当数量过大，可以使用二进制来表示。比如考虑汉字，直接找其二进制100000101010,每一步仅考虑1和0.\n  #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010; int son[N][26], cnt[N], idx; //下标是0的点，既是根节点，又是空节点 char str[N]; void insert(char str[]) { int p = 0; for(int i = 0; str[i]; ++i){ int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++; } int query(char str[]) { int p = 0; for(int i = 0; str[i]; ++i) { int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; cin \u0026gt;\u0026gt; n; while(n--) { char op[2]; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; str; if (op[0] == 'I') insert(str); else cout \u0026lt;\u0026lt; query(str) \u0026lt;\u0026lt; endl; } return 0; }  并查集 # 面试和比赛，非常容易出的数据结构。\n用来快速的处理：\n 将两个集合合并 询问两个元素是否在一个集合当中  belong[x] = a，存储x属于集合a。\n近乎O（1）的支持上面的两个操作。\n基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示父节点。\n 问题1： 如何判断树根 p== x, x就是集合的编号 问题2：如何求x的集合编号，while(p! = x) x = p 问题3：如何合并两个集合：假设px是x的集合的编号，py是y的集合的编号，那么p= y;    并查集的优化：\n （路径压缩）, 每次查询其父节点，只要直接指向其祖宗节点。  合并集合\nhttps://www.acwing.com/problem/content/838/\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; int p[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) p[i] = i; while(m --) { char op[2]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车 int a, b; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(op[0] == 'M') p[find(a)] = find(b); else { if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } } }  连通块中点的数量https://www.acwing.com/problem/content/839/\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; //如何查询每个联通块的数量？维护根节点的size即可。 int p[N], siz[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) { p[i] = i; siz[i] = 1; } while(m --) { char op[5]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车 int a, b; cin \u0026gt;\u0026gt; op; if(op[0] == 'C') { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) != find(b)) siz[find(b)] += siz[find(a)]; p[find(a)] = find(b); } else if (op[1] == '1') { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) == find(b)) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } else { cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; siz[find(a)] \u0026lt;\u0026lt; endl; } } }  堆 # 如何手写一个堆？\n 插入一个数 求集合当中的最小值 删除最小值 删除任意一个元素 修改任意一个元素  堆的基本结构：\n是一棵二叉树。是一棵完全二叉树。\n以小顶堆为例，每个节点的左右子节点都大于该节点的值。\n使用一个一维数组存放堆。\n1号点是根节点，x的左儿子是2x，右子节点是2x+1。\n操作：\n down(x)，往下调整x。每次找这个节点和两个子节点的最小值，然后交换即可。 up(x)，往上调整x。每次往上和父节点比较，需要交换时交换即可。  怎么插入x？\n heap[ ++ idx] = x; up(x);  最小值：\n heap[1]  删除最小值：\n heap[1] = heap[idx]; idx—; down(1);  删除任意元素\n heap[k] = heap[size], size—; down(k); up(k);  修改元素：\n heap[k] = x; down(k); up(k);  #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], idx; void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ swap(h[u], h[t]); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { swap(h[u/2], h[u]); u/=2; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;h[i]); idx = n; for(int i = n/2; i ; -- i) down(i); /*这是建立堆的过程 为什么从n/2开始down？ n/2的子孩子是最后一个元素，是完全二叉树的倒数第二层，所以这样一直递归 的做就好，而且时间复杂度是O(n); */ while(m--) { printf(\u0026quot;%d \u0026quot;, h[1]); h[1] = h[idx]; idx --; down(1); } return 0; }  带映射版的堆操作:\nhttps://www.acwing.com/problem/content/841/\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int n; int h[N], ph[N], hp[N], idx; //ph存放插入的第k个元素在堆的下标位置 //hp存放的是堆中第j个元素在ph数组的位置索引。 //ph和hp是互为反函数。 void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ heap_swap(u, t); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { heap_swap(u/2, u); u/=2; } } int main() { cin \u0026gt;\u0026gt; n; int m = 0; //m是第m个插入的元素。 while(n --) { char op[10]; int k, x; cin \u0026gt;\u0026gt; op; if (!strcmp(op, \u0026quot;I\u0026quot;)) { cin \u0026gt;\u0026gt; x; idx ++; m ++; ph[m] = idx; hp[idx] = m; h[idx] = x; up(idx); } else if (!strcmp(op, \u0026quot;PM\u0026quot;)) cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; endl; else if (!strcmp(op, \u0026quot;DM\u0026quot;)) { heap_swap(1, idx); idx --; down(1); } else if(!strcmp(op, \u0026quot;D\u0026quot;)) { cin \u0026gt;\u0026gt; k; k = ph[k]; heap_swap(k, idx); idx --; down(k), up(k); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; k = ph[k]; h[k] = x; down(k), up(k); } } return 0; }  find()和cnt()可以改成，get()和cnt()保证不编译错误，compile ERROR。\nHash表 #   哈希表的存储结构，认为是O(1). 如果要删除，只要开个数组标记一下。\n  开放寻址法\n  拉链法\n    常见情景： 把0-10^9的数映射到0-10^5的数组。\nx mod 10 ^ 5 附近的质数。然后处理冲突。100003.\n和离散化比较，离散是需要保序的。\n  常用的字符串的哈希方式。\n  //拉链法 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt;//有memset using namespace std; const int N = 100003; //取大于10万的最小的质数。 int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; //因为有的数是负数。 e[idx] = x; //e存值 ne[idx] = h[k]; //ne存指针 h[k] = idx; idx ++; //插入头部。 } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; memset(h, -1, sizeof h); cin \u0026gt;\u0026gt; n; while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; if(op[0] == 'I') insert(x); else { if (find(x)) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } } return 0; }    //开放寻址法 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; //0xf3f3f3f3是10^9级别，很大，用来初始化数组 const int N = 2e5 + 3, null = 0x3f3f3f3f; //一般取三倍。 //取质数。 int h[N]; int find(int x) { int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x) { k ++; if(k == N) k = 0; } //这个过程一定会停止的，因为总共只有1e5个数字，而N是二倍，所以不担心满; //结束条件时，h[k] == null 或 h[k] == x return k; } int main(){ int n; cin \u0026gt;\u0026gt; n; memset(h, 0x3f, sizeof h); while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; int k = find(x); if (op[0] == 'I') { h[k] = x; } else { if (h[k] != null) puts(\u0026quot;Yes\u0026quot;); else puts(\u0026quot;No\u0026quot;); } } return 0; }  字符串前缀哈希法。\n str = \u0026ldquo;ABCDEF\u0026rdquo; h[1] = \u0026ldquo;A\u0026rdquo; // 前1个 h[2] = \u0026ldquo;AB\u0026rdquo;\n 即处理前缀的hash，h[0] = 0\n如果对字符串进行哈希？当成p进制数，a * p ^ 3 + b * p * 2 ……;再取模Q。\n不能把字母映射成0.\n  那么前缀哈希值有什么用呢？因为我们已经知道 h[L]到h[R]的哈希值\n所以求L - R的哈希值，只要 h[R] - h[L - 1] * p ^ {R-L+1};\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; //p是存放P的n次方 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; str + 1; p[0] = 1; for(int i = 1; i \u0026lt;= n; ++ i) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while( m --) { int l1, r1, l2, r2; cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2; if(get(l1, r1) == get(l2, r2)) { puts(\u0026quot;Yes\u0026quot;); } else { puts(\u0026quot;No\u0026quot;); } } return 0; }  hash算法求两个字符串相同比KMP更好\nKMP更适合循环节。\nC++STL使用 # vector 可变长数组，倍增的思想 string 处理字符串的利器，substr(), c_str() queue, 队列，进行push(),front(), pop() priority_queue，优先队列，堆，push(), top(), pop() stack 栈，Push(), top(), pop() deque 双端队列 set, map, multiset, multimap 基于平衡二叉树（红黑树）动态维护有序序列 unordered_set, unordered_map, unordered_multiset, unordered_multimap 哈希表 bitset;压位 list用的不多。  vector: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a(10, 3); vector\u0026lt;int\u0026gt; b[10]; //定义数组 //定义一个长度为10的，初始值为3的vector //for(auto x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; a.size(); //O(1) a.empty(); a.clear();//清空 /*系统分配空间时，所需时间与空间大小无关，与申请次数有关！！！ 所以尽量减少申请空间的次数。 vector最初分配32的空间，然后如果不够，分配64，然后copy过去之前的元素。 申请长度为2 ^ n的数组，那么需要copy(1 + 2 + 2^n-1) = 2^n可以认为是O(1) 申请空间的次数是log(2^n) = n */ a.front(); a.back(); a.push_back(); a.pop_back(); begin(); end(); []; a \u0026lt; b可以判断两个vector的大小，按字典序比。 return 0; }  下面是模板 # C++ STL简介 vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair\u0026lt;int, int\u0026gt;p; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） p = make_pair(10, 2); p = {10, 2}; pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;p;存三个 string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 用于用printf输出 支持加运算： string a = \u0026quot;1\u0026quot;; a += \u0026quot;bcd\u0026quot;; queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大顶堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小顶堆的方式： priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; priority_queue\u0026lt;int\u0026gt; heap; 可以通过插入-x实现小顶堆。 stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列，加强版vector，效率低，尽量不用 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() 迭代器 [] 支持直接索引 set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset set不允许重复元素 insert() 插入一个数 find() 查找一个数，返回迭代器，找不到返回end迭代器 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() map\u0026lt;string ,int\u0026gt; a; a[\u0026quot;yxc\u0026quot;] = 1; cout \u0026lt;\u0026lt; a[\u0026quot;yec\u0026quot;] \u0026lt;\u0026lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--. bitset, 圧位 是bool数组的1/8。🐂 bitset\u0026lt;10000\u0026gt; s; ~s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing  "
      })
      .add(
      {
        id: 2,
        href: "/docs/prologue/introduction/",
        title: "Introduction",
        description: "Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",
        content: "Get started # Step-by-step instructions on how to start a new Doks project. Tutorial →\n"
      })
      .add(
      {
        id: 3,
        href: "/docs/prologue/commands/",
        title: "Commands",
        description: "Doks comes with commands for common tasks.",
        content: "💡  You can change the commands in the scripts section of `./package.json`.   create # Create new content for your site:\nnpm run create [path] [flags]  See also the Hugo docs: hugo new.\nlint # Check scripts, styles, and markdown for errors:\nnpm run lint  scripts # Check scripts for errors:\nnpm run lint:scripts [-- --fix]  styles # Check styles for errors:\nnpm run lint:styles [-- --fix]  markdown # Check markdown for errors:\nnpm run lint:markdown [-- --fix]  clean # Delete temporary directories:\nnpm run clean  start # Start local development server:\nnpm run start  build # Build production website:\nnpm run build  functions # Build Lambda functions:\nnpm run build:functions  preview # Build production website including draft and future content:\nnpm run build:preview  "
      })
      .add(
      {
        id: 4,
        href: "/docs/prologue/",
        title: "Prologue",
        description: "Prologue Doks.",
        content: ""
      })
      .add(
      {
        id: 5,
        href: "/docs/algorithm/",
        title: "al",
        description: "Docs Doks.",
        content: ""
      })
      .add(
      {
        id: 6,
        href: "/docs/",
        title: "Docs",
        description: "Docs Doks.",
        content: ""
      })
      ;

  search.addEventListener('input', show_results, true);

  function show_results(){
    const maxResult = 5;
    var searchQuery = this.value;
    var results = index.search(searchQuery, {limit: maxResult, enrich: true});

    // flatten results since index.search() returns results for each indexed field
    const flatResults = new Map(); // keyed by href to dedupe results
    for (const result of results.flatMap(r => r.result)) {
      if (flatResults.has(result.doc.href)) continue;
      flatResults.set(result.doc.href, result.doc);
    }

    suggestions.innerHTML = "";
    suggestions.classList.remove('d-none');

    // inform user that no results were found
    if (flatResults.size === 0 && searchQuery) {
      const noResultsMessage = document.createElement('div')
      noResultsMessage.innerHTML = `No results for "<strong>${searchQuery}</strong>"`
      noResultsMessage.classList.add("suggestion__no-results");
      suggestions.appendChild(noResultsMessage);
      return;
    }

    // construct a list of suggestions
    for(const [href, doc] of flatResults) {
        const entry = document.createElement('div');
        suggestions.appendChild(entry);

        const a = document.createElement('a');
        a.href = href;
        entry.appendChild(a);

        const title = document.createElement('span');
        title.textContent = doc.title;
        title.classList.add("suggestion__title");
        a.appendChild(title);

        const description = document.createElement('span');
        description.textContent = doc.description;
        description.classList.add("suggestion__description");
        a.appendChild(description);

        suggestions.appendChild(entry);

        if(suggestions.childElementCount == maxResult) break;
    }
  }
}());
